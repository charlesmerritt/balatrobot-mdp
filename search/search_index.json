{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"A framework for developing Balatro bots <p>BalatroBot is a Python framework designed to help developers create automated bots for the card game Balatro. The framework provides a comprehensive API for interacting with the game, handling game state, making strategic decisions, and executing actions. Whether you're building a simple bot or a sophisticated AI player, BalatroBot offers the tools and structure needed to get started quickly.</p> <ul> <li> <p> Installation</p> <p>Setup guide covering prerequisites, Steamodded mod installation, and Python environment setup.</p> <p> Installation</p> </li> <li> <p> Developing Bots</p> <p>Learn to develop bots with complete code examples, class structure, and game state handling.</p> <p> Developing Bots</p> </li> <li> <p> Protocol API</p> <p>Technical reference for TCP socket communication, message formats, game states, and action types.</p> <p> Protocol API</p> </li> <li> <p> Documentation for LLM</p> <p>Documentation in llms.txt format. Just paste the following link (or its content) into the LLM chat.</p> <p> llms-full.txt</p> </li> </ul>"},{"location":"balatrobot-api/","title":"BalatroBot API","text":"<p>This page provides comprehensive API documentation for the BalatroBot Python framework. The API enables you to build automated bots that interact with the Balatro card game through a structured TCP communication protocol.</p> <p>The API is organized into several key components: the <code>BalatroClient</code> for managing game connections and sending commands, enums that define game states and actions, exception classes for robust error handling, and data models that structure requests and responses between your bot and the game.</p>"},{"location":"balatrobot-api/#client","title":"Client","text":"<p>The <code>BalatroClient</code> is the main interface for communicating with the Balatro game through TCP connections. It handles connection management, message serialization, and error handling.</p>"},{"location":"balatrobot-api/#balatrobot.client.BalatroClient","title":"<code>balatrobot.client.BalatroClient</code>","text":"<p>Client for communicating with the BalatroBot game API.</p> <p>The client provides methods for game control, state management, and development tools including a checkpointing system for saving and loading game states.</p> <p>Attributes:</p> Name Type Description <code>host</code> <p>Host address to connect to</p> <code>port</code> <p>Port number to connect to</p> <code>timeout</code> <p>Socket timeout in seconds</p> <code>buffer_size</code> <p>Socket buffer size in bytes</p> <code>_socket</code> <code>socket | None</code> <p>Socket connection to BalatroBot</p> Source code in <code>src/balatrobot/client.py</code> <pre><code>class BalatroClient:\n    \"\"\"Client for communicating with the BalatroBot game API.\n\n    The client provides methods for game control, state management, and development tools\n    including a checkpointing system for saving and loading game states.\n\n    Attributes:\n        host: Host address to connect to\n        port: Port number to connect to\n        timeout: Socket timeout in seconds\n        buffer_size: Socket buffer size in bytes\n        _socket: Socket connection to BalatroBot\n    \"\"\"\n\n    host = \"127.0.0.1\"\n    timeout = 300.0\n    buffer_size = 65536\n\n    def __init__(self, port: int = 12346, timeout: float | None = None):\n        \"\"\"Initialize BalatroBot client\n\n        Args:\n            port: Port number to connect to (default: 12346)\n            timeout: Socket timeout in seconds (default: 300.0)\n        \"\"\"\n        self.port = port\n        self.timeout = timeout if timeout is not None else self.timeout\n        self._socket: socket.socket | None = None\n        self._connected = False\n        self._message_buffer = b\"\"  # Buffer for incomplete messages\n\n    def _receive_complete_message(self) -&gt; bytes:\n        \"\"\"Receive a complete message from the socket, handling message boundaries properly.\"\"\"\n        if not self._connected or not self._socket:\n            raise ConnectionFailedError(\n                \"Socket not connected\",\n                error_code=\"E008\",\n                context={\n                    \"connected\": self._connected,\n                    \"socket\": self._socket is not None,\n                },\n            )\n\n        # Check if we already have a complete message in the buffer\n        while b\"\\n\" not in self._message_buffer:\n            try:\n                chunk = self._socket.recv(self.buffer_size)\n            except socket.timeout:\n                raise ConnectionFailedError(\n                    \"Socket timeout while receiving data\",\n                    error_code=\"E008\",\n                    context={\n                        \"timeout\": self.timeout,\n                        \"buffer_size\": len(self._message_buffer),\n                    },\n                )\n            except socket.error as e:\n                raise ConnectionFailedError(\n                    f\"Socket error while receiving: {e}\",\n                    error_code=\"E008\",\n                    context={\"error\": str(e), \"buffer_size\": len(self._message_buffer)},\n                )\n\n            if not chunk:\n                raise ConnectionFailedError(\n                    \"Connection closed by server\",\n                    error_code=\"E008\",\n                    context={\"buffer_size\": len(self._message_buffer)},\n                )\n            self._message_buffer += chunk\n\n        # Extract the first complete message\n        message_end = self._message_buffer.find(b\"\\n\")\n        complete_message = self._message_buffer[:message_end]\n\n        # Update buffer to remove the processed message\n        remaining_data = self._message_buffer[message_end + 1 :]\n        self._message_buffer = remaining_data\n\n        # Log any remaining data for debugging\n        if remaining_data:\n            logger.warning(f\"Data remaining in buffer: {len(remaining_data)} bytes\")\n            logger.debug(f\"Buffer preview: {remaining_data[:100]}...\")\n\n        return complete_message\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"Enter context manager and connect to the game.\"\"\"\n        self.connect()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        \"\"\"Exit context manager and disconnect from the game.\"\"\"\n        self.disconnect()\n\n    def connect(self) -&gt; None:\n        \"\"\"Connect to Balatro TCP server\n\n        Raises:\n            ConnectionFailedError: If not connected to the game\n        \"\"\"\n        if self._connected:\n            return\n\n        logger.info(f\"Connecting to BalatroBot API at {self.host}:{self.port}\")\n        try:\n            self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self._socket.settimeout(self.timeout)\n            self._socket.setsockopt(\n                socket.SOL_SOCKET, socket.SO_RCVBUF, self.buffer_size\n            )\n            self._socket.connect((self.host, self.port))\n            self._connected = True\n            logger.info(\n                f\"Successfully connected to BalatroBot API at {self.host}:{self.port}\"\n            )\n        except (socket.error, OSError) as e:\n            logger.error(f\"Failed to connect to {self.host}:{self.port}: {e}\")\n            raise ConnectionFailedError(\n                f\"Failed to connect to {self.host}:{self.port}\",\n                error_code=\"E008\",\n                context={\"host\": self.host, \"port\": self.port, \"error\": str(e)},\n            ) from e\n\n    def disconnect(self) -&gt; None:\n        \"\"\"Disconnect from the BalatroBot game API.\"\"\"\n        if self._socket:\n            logger.info(f\"Disconnecting from BalatroBot API at {self.host}:{self.port}\")\n            self._socket.close()\n            self._socket = None\n        self._connected = False\n        # Clear message buffer on disconnect\n        self._message_buffer = b\"\"\n\n    def send_message(self, name: str, arguments: dict | None = None) -&gt; dict:\n        \"\"\"Send JSON message to Balatro and receive response\n\n        Args:\n            name: Function name to call\n            arguments: Function arguments\n\n        Returns:\n            Response from the game API\n\n        Raises:\n            ConnectionFailedError: If not connected to the game\n            BalatroError: If the API returns an error\n        \"\"\"\n        if arguments is None:\n            arguments = {}\n\n        if not self._connected or not self._socket:\n            raise ConnectionFailedError(\n                \"Not connected to the game API\",\n                error_code=\"E008\",\n                context={\n                    \"connected\": self._connected,\n                    \"socket\": self._socket is not None,\n                },\n            )\n\n        # Create and validate request\n        request = APIRequest(name=name, arguments=arguments)\n        logger.debug(f\"Sending API request: {name}\")\n\n        try:\n            # Start timing measurement\n            start_time = time.perf_counter()\n\n            # Send request\n            message = request.model_dump_json() + \"\\n\"\n            self._socket.send(message.encode())\n\n            # Receive response using improved message handling\n            complete_message = self._receive_complete_message()\n\n            # Decode and validate the message\n            message_str = complete_message.decode().strip()\n            logger.debug(f\"Raw message length: {len(message_str)} characters\")\n            logger.debug(f\"Message preview: {message_str[:100]}...\")\n\n            # Ensure the message is properly formatted JSON\n            if not message_str:\n                raise BalatroError(\n                    \"Empty response received from game\",\n                    error_code=\"E001\",\n                    context={\"raw_data_length\": len(complete_message)},\n                )\n\n            response_data = json.loads(message_str)\n\n            # Check for error response\n            if \"error\" in response_data:\n                logger.error(f\"API request {name} failed: {response_data.get('error')}\")\n                raise create_exception_from_error_response(response_data)\n\n            logger.debug(f\"API request {name} completed successfully\")\n            return response_data\n\n        except socket.timeout as e:\n            # Calculate elapsed time and log timeout\n            elapsed_time = time.perf_counter() - start_time\n            logger.warning(\n                f\"Timeout on API request {name}: took {elapsed_time:.3f}s, \"\n                f\"exceeded timeout of {self.timeout}s (port: {self.port})\"\n            )\n            raise ConnectionFailedError(\n                f\"Socket timeout during communication: {e}\",\n                error_code=\"E008\",\n                context={\"error\": str(e), \"elapsed_time\": elapsed_time},\n            ) from e\n        except socket.error as e:\n            logger.error(f\"Socket error during API request {name}: {e}\")\n            raise ConnectionFailedError(\n                f\"Socket error during communication: {e}\",\n                error_code=\"E008\",\n                context={\"error\": str(e)},\n            ) from e\n        except json.JSONDecodeError as e:\n            logger.error(f\"Invalid JSON response from API request {name}: {e}\")\n            logger.error(f\"Problematic message content: {message_str[:200]}...\")\n            logger.error(\n                f\"Message buffer state: {len(self._message_buffer)} bytes remaining\"\n            )\n\n            # Clear the message buffer to prevent cascading errors\n            if self._message_buffer:\n                logger.warning(\"Clearing message buffer due to JSON parse error\")\n                self._message_buffer = b\"\"\n\n            raise BalatroError(\n                f\"Invalid JSON response from game: {e}\",\n                error_code=\"E001\",\n                context={\"error\": str(e), \"message_preview\": message_str[:100]},\n            ) from e\n\n    # Checkpoint Management Methods\n\n    def _convert_windows_path_to_linux(self, windows_path: str) -&gt; str:\n        \"\"\"Convert Windows path to Linux Steam Proton path if on Linux.\n\n        Args:\n            windows_path: Windows-style path (e.g., \"C:/Users/.../Balatro/3/save.jkr\")\n\n        Returns:\n            Converted path for Linux or original path for other platforms\n        \"\"\"\n\n        if platform.system() == \"Linux\":\n            # Match Windows drive letter and path (e.g., \"C:/...\", \"D:\\\\...\", \"E:...\")\n            match = re.match(r\"^([A-Z]):[\\\\/]*(.*)\", windows_path, re.IGNORECASE)\n            if match:\n                # Replace drive letter with Linux Steam Proton prefix\n                linux_prefix = str(\n                    Path(\n                        \"~/.steam/steam/steamapps/compatdata/2379780/pfx/drive_c\"\n                    ).expanduser()\n                )\n                # Normalize slashes and join with prefix\n                rest_of_path = match.group(2).replace(\"\\\\\", \"/\")\n                return linux_prefix + \"/\" + rest_of_path\n\n        return windows_path\n\n    def get_save_info(self) -&gt; dict:\n        \"\"\"Get the current save file location and profile information.\n\n        Development tool for working with save files and checkpoints.\n\n        Returns:\n            Dictionary containing:\n            - profile_path: Current profile path (e.g., \"3\")\n            - save_directory: Full path to Love2D save directory\n            - save_file_path: Full OS-specific path to save.jkr file\n            - has_active_run: Whether a run is currently active\n            - save_exists: Whether the save file exists\n\n        Raises:\n            BalatroError: If request fails\n\n        Note:\n            This is primarily for development and testing purposes.\n        \"\"\"\n        save_info = self.send_message(\"get_save_info\")\n\n        # Convert Windows paths to Linux Steam Proton paths if needed\n        if \"save_file_path\" in save_info and save_info[\"save_file_path\"]:\n            save_info[\"save_file_path\"] = self._convert_windows_path_to_linux(\n                save_info[\"save_file_path\"]\n            )\n        if \"save_directory\" in save_info and save_info[\"save_directory\"]:\n            save_info[\"save_directory\"] = self._convert_windows_path_to_linux(\n                save_info[\"save_directory\"]\n            )\n\n        return save_info\n\n    def save_checkpoint(self, checkpoint_name: str | Path) -&gt; Path:\n        \"\"\"Save the current save.jkr file as a checkpoint.\n\n        Args:\n            checkpoint_name: Either:\n                - A checkpoint name (saved to checkpoints dir)\n                - A full file path where the checkpoint should be saved\n                - A directory path (checkpoint will be saved as 'save.jkr' inside it)\n\n        Returns:\n            Path to the saved checkpoint file\n\n        Raises:\n            BalatroError: If no save file exists or the destination path is invalid\n            IOError: If file operations fail\n        \"\"\"\n        # Get current save info\n        save_info = self.get_save_info()\n        if not save_info.get(\"save_exists\"):\n            raise BalatroError(\n                \"No save file exists to checkpoint\", ErrorCode.INVALID_GAME_STATE\n            )\n\n        # Get the full save file path from API (already OS-specific)\n        save_path = Path(save_info[\"save_file_path\"])\n        if not save_path.exists():\n            raise BalatroError(\n                f\"Save file not found: {save_path}\", ErrorCode.MISSING_GAME_OBJECT\n            )\n\n        # Normalize and interpret destination\n        dest = Path(checkpoint_name).expanduser()\n        # Treat paths without a .jkr suffix as directories\n        if dest.suffix.lower() != \".jkr\":\n            raise BalatroError(\n                f\"Invalid checkpoint path provided: {dest}\",\n                ErrorCode.INVALID_PARAMETER,\n                context={\"path\": str(dest), \"reason\": \"Path does not end with .jkr\"},\n            )\n\n        # Ensure destination directory exists\n        try:\n            dest.parent.mkdir(parents=True, exist_ok=True)\n        except OSError as e:\n            raise BalatroError(\n                f\"Invalid checkpoint path provided: {dest}\",\n                ErrorCode.INVALID_PARAMETER,\n                context={\"path\": str(dest), \"reason\": str(e)},\n            ) from e\n\n        # Copy save file to checkpoint\n        try:\n            shutil.copy2(save_path, dest)\n        except OSError as e:\n            raise BalatroError(\n                f\"Failed to write checkpoint to: {dest}\",\n                ErrorCode.INVALID_PARAMETER,\n                context={\"path\": str(dest), \"reason\": str(e)},\n            ) from e\n\n        return dest\n\n    def prepare_save(self, source_path: str | Path) -&gt; str:\n        \"\"\"Prepare a test save file for use with load_save.\n\n        This copies a .jkr file from your test directory into Love2D's save directory\n        in a temporary profile so it can be loaded with load_save().\n\n        Args:\n            source_path: Path to the .jkr save file to prepare\n\n        Returns:\n            The Love2D-relative path to use with load_save()\n            (e.g., \"checkpoint/save.jkr\")\n\n        Raises:\n            BalatroError: If source file not found\n            IOError: If file operations fail\n        \"\"\"\n        source = Path(source_path)\n        if not source.exists():\n            raise BalatroError(\n                f\"Source save file not found: {source}\", ErrorCode.MISSING_GAME_OBJECT\n            )\n\n        # Get save directory info\n        save_info = self.get_save_info()\n        if not save_info.get(\"save_directory\"):\n            raise BalatroError(\n                \"Cannot determine Love2D save directory\", ErrorCode.INVALID_GAME_STATE\n            )\n\n        checkpoints_profile = \"checkpoint\"\n        save_dir = Path(save_info[\"save_directory\"])\n        checkpoints_dir = save_dir / checkpoints_profile\n        checkpoints_dir.mkdir(parents=True, exist_ok=True)\n\n        # Copy the save file to the test profile\n        dest_path = checkpoints_dir / \"save.jkr\"\n        shutil.copy2(source, dest_path)\n\n        # Return the Love2D-relative path\n        return f\"{checkpoints_profile}/save.jkr\"\n\n    def load_save(self, save_path: str | Path) -&gt; dict:\n        \"\"\"Load a save file directly without requiring a game restart.\n\n        This method loads a save file (in Love2D's save directory format) and starts\n        a run from that save state. Unlike load_checkpoint which copies to the profile's\n        save location and requires restart, this directly loads the save into the game.\n\n        This is particularly useful for testing as it allows you to quickly jump to\n        specific game states without manual setup.\n\n        Args:\n            save_path: Path to the save file relative to Love2D save directory\n                      (e.g., \"3/save.jkr\" for profile 3's save)\n\n        Returns:\n            Game state after loading the save\n\n        Raises:\n            BalatroError: If save file not found or loading fails\n\n        Note:\n            This is a development tool that bypasses normal game flow.\n            Use with caution in production bots.\n\n        Example:\n            ```python\n            # Load a profile's save directly\n            game_state = client.load_save(\"3/save.jkr\")\n\n            # Or use with prepare_save for external files\n            save_path = client.prepare_save(\"tests/fixtures/shop_state.jkr\")\n            game_state = client.load_save(save_path)\n            ```\n        \"\"\"\n        # Convert to string if Path object\n        if isinstance(save_path, Path):\n            save_path = str(save_path)\n\n        # Send load_save request to API\n        return self.send_message(\"load_save\", {\"save_path\": save_path})\n\n    def load_absolute_save(self, save_path: str | Path) -&gt; dict:\n        \"\"\"Load a save from an absolute path. Takes a full path from the OS as a .jkr file and loads it into the game.\n\n        Args:\n            save_path: Path to the save file relative to Love2D save directory\n                      (e.g., \"3/save.jkr\" for profile 3's save)\n\n        Returns:\n            Game state after loading the save\n        \"\"\"\n        love_save_path = self.prepare_save(save_path)\n        return self.load_save(love_save_path)\n\n    def screenshot(self, path: Path | None = None) -&gt; Path:\n        \"\"\"\n        Take a screenshot and save as both PNG and JPEG formats.\n\n        Args:\n            path: Optional path for PNG file. If provided, PNG will be moved to this location.\n\n        Returns:\n            Path to the PNG screenshot. JPEG is saved alongside with .jpg extension.\n\n        Note:\n            The response now includes both 'path' (PNG) and 'jpeg_path' (JPEG) keys.\n            This method maintains backward compatibility by returning the PNG path.\n        \"\"\"\n        screenshot_response = self.send_message(\"screenshot\", {})\n\n        if path is None:\n            return Path(screenshot_response[\"path\"])\n        else:\n            source_path = Path(screenshot_response[\"path\"])\n            dest_path = path\n            shutil.move(source_path, dest_path)\n            return dest_path\n</code></pre>"},{"location":"balatrobot-api/#balatrobot.client.BalatroClient.connect","title":"<code>connect()</code>","text":"<p>Connect to Balatro TCP server</p> <p>Raises:</p> Type Description <code>ConnectionFailedError</code> <p>If not connected to the game</p> Source code in <code>src/balatrobot/client.py</code> <pre><code>def connect(self) -&gt; None:\n    \"\"\"Connect to Balatro TCP server\n\n    Raises:\n        ConnectionFailedError: If not connected to the game\n    \"\"\"\n    if self._connected:\n        return\n\n    logger.info(f\"Connecting to BalatroBot API at {self.host}:{self.port}\")\n    try:\n        self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self._socket.settimeout(self.timeout)\n        self._socket.setsockopt(\n            socket.SOL_SOCKET, socket.SO_RCVBUF, self.buffer_size\n        )\n        self._socket.connect((self.host, self.port))\n        self._connected = True\n        logger.info(\n            f\"Successfully connected to BalatroBot API at {self.host}:{self.port}\"\n        )\n    except (socket.error, OSError) as e:\n        logger.error(f\"Failed to connect to {self.host}:{self.port}: {e}\")\n        raise ConnectionFailedError(\n            f\"Failed to connect to {self.host}:{self.port}\",\n            error_code=\"E008\",\n            context={\"host\": self.host, \"port\": self.port, \"error\": str(e)},\n        ) from e\n</code></pre>"},{"location":"balatrobot-api/#balatrobot.client.BalatroClient.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect from the BalatroBot game API.</p> Source code in <code>src/balatrobot/client.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the BalatroBot game API.\"\"\"\n    if self._socket:\n        logger.info(f\"Disconnecting from BalatroBot API at {self.host}:{self.port}\")\n        self._socket.close()\n        self._socket = None\n    self._connected = False\n    # Clear message buffer on disconnect\n    self._message_buffer = b\"\"\n</code></pre>"},{"location":"balatrobot-api/#balatrobot.client.BalatroClient.get_save_info","title":"<code>get_save_info()</code>","text":"<p>Get the current save file location and profile information.</p> <p>Development tool for working with save files and checkpoints.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing:</p> <code>dict</code> <ul> <li>profile_path: Current profile path (e.g., \"3\")</li> </ul> <code>dict</code> <ul> <li>save_directory: Full path to Love2D save directory</li> </ul> <code>dict</code> <ul> <li>save_file_path: Full OS-specific path to save.jkr file</li> </ul> <code>dict</code> <ul> <li>has_active_run: Whether a run is currently active</li> </ul> <code>dict</code> <ul> <li>save_exists: Whether the save file exists</li> </ul> <p>Raises:</p> Type Description <code>BalatroError</code> <p>If request fails</p> Note <p>This is primarily for development and testing purposes.</p> Source code in <code>src/balatrobot/client.py</code> <pre><code>def get_save_info(self) -&gt; dict:\n    \"\"\"Get the current save file location and profile information.\n\n    Development tool for working with save files and checkpoints.\n\n    Returns:\n        Dictionary containing:\n        - profile_path: Current profile path (e.g., \"3\")\n        - save_directory: Full path to Love2D save directory\n        - save_file_path: Full OS-specific path to save.jkr file\n        - has_active_run: Whether a run is currently active\n        - save_exists: Whether the save file exists\n\n    Raises:\n        BalatroError: If request fails\n\n    Note:\n        This is primarily for development and testing purposes.\n    \"\"\"\n    save_info = self.send_message(\"get_save_info\")\n\n    # Convert Windows paths to Linux Steam Proton paths if needed\n    if \"save_file_path\" in save_info and save_info[\"save_file_path\"]:\n        save_info[\"save_file_path\"] = self._convert_windows_path_to_linux(\n            save_info[\"save_file_path\"]\n        )\n    if \"save_directory\" in save_info and save_info[\"save_directory\"]:\n        save_info[\"save_directory\"] = self._convert_windows_path_to_linux(\n            save_info[\"save_directory\"]\n        )\n\n    return save_info\n</code></pre>"},{"location":"balatrobot-api/#balatrobot.client.BalatroClient.load_absolute_save","title":"<code>load_absolute_save(save_path)</code>","text":"<p>Load a save from an absolute path. Takes a full path from the OS as a .jkr file and loads it into the game.</p> <p>Parameters:</p> Name Type Description Default <code>save_path</code> <code>str | Path</code> <p>Path to the save file relative to Love2D save directory       (e.g., \"3/save.jkr\" for profile 3's save)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Game state after loading the save</p> Source code in <code>src/balatrobot/client.py</code> <pre><code>def load_absolute_save(self, save_path: str | Path) -&gt; dict:\n    \"\"\"Load a save from an absolute path. Takes a full path from the OS as a .jkr file and loads it into the game.\n\n    Args:\n        save_path: Path to the save file relative to Love2D save directory\n                  (e.g., \"3/save.jkr\" for profile 3's save)\n\n    Returns:\n        Game state after loading the save\n    \"\"\"\n    love_save_path = self.prepare_save(save_path)\n    return self.load_save(love_save_path)\n</code></pre>"},{"location":"balatrobot-api/#balatrobot.client.BalatroClient.load_save","title":"<code>load_save(save_path)</code>","text":"<p>Load a save file directly without requiring a game restart.</p> <p>This method loads a save file (in Love2D's save directory format) and starts a run from that save state. Unlike load_checkpoint which copies to the profile's save location and requires restart, this directly loads the save into the game.</p> <p>This is particularly useful for testing as it allows you to quickly jump to specific game states without manual setup.</p> <p>Parameters:</p> Name Type Description Default <code>save_path</code> <code>str | Path</code> <p>Path to the save file relative to Love2D save directory       (e.g., \"3/save.jkr\" for profile 3's save)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Game state after loading the save</p> <p>Raises:</p> Type Description <code>BalatroError</code> <p>If save file not found or loading fails</p> Note <p>This is a development tool that bypasses normal game flow. Use with caution in production bots.</p> Example <pre><code># Load a profile's save directly\ngame_state = client.load_save(\"3/save.jkr\")\n\n# Or use with prepare_save for external files\nsave_path = client.prepare_save(\"tests/fixtures/shop_state.jkr\")\ngame_state = client.load_save(save_path)\n</code></pre> Source code in <code>src/balatrobot/client.py</code> <pre><code>def load_save(self, save_path: str | Path) -&gt; dict:\n    \"\"\"Load a save file directly without requiring a game restart.\n\n    This method loads a save file (in Love2D's save directory format) and starts\n    a run from that save state. Unlike load_checkpoint which copies to the profile's\n    save location and requires restart, this directly loads the save into the game.\n\n    This is particularly useful for testing as it allows you to quickly jump to\n    specific game states without manual setup.\n\n    Args:\n        save_path: Path to the save file relative to Love2D save directory\n                  (e.g., \"3/save.jkr\" for profile 3's save)\n\n    Returns:\n        Game state after loading the save\n\n    Raises:\n        BalatroError: If save file not found or loading fails\n\n    Note:\n        This is a development tool that bypasses normal game flow.\n        Use with caution in production bots.\n\n    Example:\n        ```python\n        # Load a profile's save directly\n        game_state = client.load_save(\"3/save.jkr\")\n\n        # Or use with prepare_save for external files\n        save_path = client.prepare_save(\"tests/fixtures/shop_state.jkr\")\n        game_state = client.load_save(save_path)\n        ```\n    \"\"\"\n    # Convert to string if Path object\n    if isinstance(save_path, Path):\n        save_path = str(save_path)\n\n    # Send load_save request to API\n    return self.send_message(\"load_save\", {\"save_path\": save_path})\n</code></pre>"},{"location":"balatrobot-api/#balatrobot.client.BalatroClient.prepare_save","title":"<code>prepare_save(source_path)</code>","text":"<p>Prepare a test save file for use with load_save.</p> <p>This copies a .jkr file from your test directory into Love2D's save directory in a temporary profile so it can be loaded with load_save().</p> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>str | Path</code> <p>Path to the .jkr save file to prepare</p> required <p>Returns:</p> Type Description <code>str</code> <p>The Love2D-relative path to use with load_save()</p> <code>str</code> <p>(e.g., \"checkpoint/save.jkr\")</p> <p>Raises:</p> Type Description <code>BalatroError</code> <p>If source file not found</p> <code>IOError</code> <p>If file operations fail</p> Source code in <code>src/balatrobot/client.py</code> <pre><code>def prepare_save(self, source_path: str | Path) -&gt; str:\n    \"\"\"Prepare a test save file for use with load_save.\n\n    This copies a .jkr file from your test directory into Love2D's save directory\n    in a temporary profile so it can be loaded with load_save().\n\n    Args:\n        source_path: Path to the .jkr save file to prepare\n\n    Returns:\n        The Love2D-relative path to use with load_save()\n        (e.g., \"checkpoint/save.jkr\")\n\n    Raises:\n        BalatroError: If source file not found\n        IOError: If file operations fail\n    \"\"\"\n    source = Path(source_path)\n    if not source.exists():\n        raise BalatroError(\n            f\"Source save file not found: {source}\", ErrorCode.MISSING_GAME_OBJECT\n        )\n\n    # Get save directory info\n    save_info = self.get_save_info()\n    if not save_info.get(\"save_directory\"):\n        raise BalatroError(\n            \"Cannot determine Love2D save directory\", ErrorCode.INVALID_GAME_STATE\n        )\n\n    checkpoints_profile = \"checkpoint\"\n    save_dir = Path(save_info[\"save_directory\"])\n    checkpoints_dir = save_dir / checkpoints_profile\n    checkpoints_dir.mkdir(parents=True, exist_ok=True)\n\n    # Copy the save file to the test profile\n    dest_path = checkpoints_dir / \"save.jkr\"\n    shutil.copy2(source, dest_path)\n\n    # Return the Love2D-relative path\n    return f\"{checkpoints_profile}/save.jkr\"\n</code></pre>"},{"location":"balatrobot-api/#balatrobot.client.BalatroClient.save_checkpoint","title":"<code>save_checkpoint(checkpoint_name)</code>","text":"<p>Save the current save.jkr file as a checkpoint.</p> <p>Parameters:</p> Name Type Description Default <code>checkpoint_name</code> <code>str | Path</code> <p>Either: - A checkpoint name (saved to checkpoints dir) - A full file path where the checkpoint should be saved - A directory path (checkpoint will be saved as 'save.jkr' inside it)</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to the saved checkpoint file</p> <p>Raises:</p> Type Description <code>BalatroError</code> <p>If no save file exists or the destination path is invalid</p> <code>IOError</code> <p>If file operations fail</p> Source code in <code>src/balatrobot/client.py</code> <pre><code>def save_checkpoint(self, checkpoint_name: str | Path) -&gt; Path:\n    \"\"\"Save the current save.jkr file as a checkpoint.\n\n    Args:\n        checkpoint_name: Either:\n            - A checkpoint name (saved to checkpoints dir)\n            - A full file path where the checkpoint should be saved\n            - A directory path (checkpoint will be saved as 'save.jkr' inside it)\n\n    Returns:\n        Path to the saved checkpoint file\n\n    Raises:\n        BalatroError: If no save file exists or the destination path is invalid\n        IOError: If file operations fail\n    \"\"\"\n    # Get current save info\n    save_info = self.get_save_info()\n    if not save_info.get(\"save_exists\"):\n        raise BalatroError(\n            \"No save file exists to checkpoint\", ErrorCode.INVALID_GAME_STATE\n        )\n\n    # Get the full save file path from API (already OS-specific)\n    save_path = Path(save_info[\"save_file_path\"])\n    if not save_path.exists():\n        raise BalatroError(\n            f\"Save file not found: {save_path}\", ErrorCode.MISSING_GAME_OBJECT\n        )\n\n    # Normalize and interpret destination\n    dest = Path(checkpoint_name).expanduser()\n    # Treat paths without a .jkr suffix as directories\n    if dest.suffix.lower() != \".jkr\":\n        raise BalatroError(\n            f\"Invalid checkpoint path provided: {dest}\",\n            ErrorCode.INVALID_PARAMETER,\n            context={\"path\": str(dest), \"reason\": \"Path does not end with .jkr\"},\n        )\n\n    # Ensure destination directory exists\n    try:\n        dest.parent.mkdir(parents=True, exist_ok=True)\n    except OSError as e:\n        raise BalatroError(\n            f\"Invalid checkpoint path provided: {dest}\",\n            ErrorCode.INVALID_PARAMETER,\n            context={\"path\": str(dest), \"reason\": str(e)},\n        ) from e\n\n    # Copy save file to checkpoint\n    try:\n        shutil.copy2(save_path, dest)\n    except OSError as e:\n        raise BalatroError(\n            f\"Failed to write checkpoint to: {dest}\",\n            ErrorCode.INVALID_PARAMETER,\n            context={\"path\": str(dest), \"reason\": str(e)},\n        ) from e\n\n    return dest\n</code></pre>"},{"location":"balatrobot-api/#balatrobot.client.BalatroClient.screenshot","title":"<code>screenshot(path=None)</code>","text":"<p>Take a screenshot and save as both PNG and JPEG formats.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | None</code> <p>Optional path for PNG file. If provided, PNG will be moved to this location.</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the PNG screenshot. JPEG is saved alongside with .jpg extension.</p> Note <p>The response now includes both 'path' (PNG) and 'jpeg_path' (JPEG) keys. This method maintains backward compatibility by returning the PNG path.</p> Source code in <code>src/balatrobot/client.py</code> <pre><code>def screenshot(self, path: Path | None = None) -&gt; Path:\n    \"\"\"\n    Take a screenshot and save as both PNG and JPEG formats.\n\n    Args:\n        path: Optional path for PNG file. If provided, PNG will be moved to this location.\n\n    Returns:\n        Path to the PNG screenshot. JPEG is saved alongside with .jpg extension.\n\n    Note:\n        The response now includes both 'path' (PNG) and 'jpeg_path' (JPEG) keys.\n        This method maintains backward compatibility by returning the PNG path.\n    \"\"\"\n    screenshot_response = self.send_message(\"screenshot\", {})\n\n    if path is None:\n        return Path(screenshot_response[\"path\"])\n    else:\n        source_path = Path(screenshot_response[\"path\"])\n        dest_path = path\n        shutil.move(source_path, dest_path)\n        return dest_path\n</code></pre>"},{"location":"balatrobot-api/#balatrobot.client.BalatroClient.send_message","title":"<code>send_message(name, arguments=None)</code>","text":"<p>Send JSON message to Balatro and receive response</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Function name to call</p> required <code>arguments</code> <code>dict | None</code> <p>Function arguments</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Response from the game API</p> <p>Raises:</p> Type Description <code>ConnectionFailedError</code> <p>If not connected to the game</p> <code>BalatroError</code> <p>If the API returns an error</p> Source code in <code>src/balatrobot/client.py</code> <pre><code>def send_message(self, name: str, arguments: dict | None = None) -&gt; dict:\n    \"\"\"Send JSON message to Balatro and receive response\n\n    Args:\n        name: Function name to call\n        arguments: Function arguments\n\n    Returns:\n        Response from the game API\n\n    Raises:\n        ConnectionFailedError: If not connected to the game\n        BalatroError: If the API returns an error\n    \"\"\"\n    if arguments is None:\n        arguments = {}\n\n    if not self._connected or not self._socket:\n        raise ConnectionFailedError(\n            \"Not connected to the game API\",\n            error_code=\"E008\",\n            context={\n                \"connected\": self._connected,\n                \"socket\": self._socket is not None,\n            },\n        )\n\n    # Create and validate request\n    request = APIRequest(name=name, arguments=arguments)\n    logger.debug(f\"Sending API request: {name}\")\n\n    try:\n        # Start timing measurement\n        start_time = time.perf_counter()\n\n        # Send request\n        message = request.model_dump_json() + \"\\n\"\n        self._socket.send(message.encode())\n\n        # Receive response using improved message handling\n        complete_message = self._receive_complete_message()\n\n        # Decode and validate the message\n        message_str = complete_message.decode().strip()\n        logger.debug(f\"Raw message length: {len(message_str)} characters\")\n        logger.debug(f\"Message preview: {message_str[:100]}...\")\n\n        # Ensure the message is properly formatted JSON\n        if not message_str:\n            raise BalatroError(\n                \"Empty response received from game\",\n                error_code=\"E001\",\n                context={\"raw_data_length\": len(complete_message)},\n            )\n\n        response_data = json.loads(message_str)\n\n        # Check for error response\n        if \"error\" in response_data:\n            logger.error(f\"API request {name} failed: {response_data.get('error')}\")\n            raise create_exception_from_error_response(response_data)\n\n        logger.debug(f\"API request {name} completed successfully\")\n        return response_data\n\n    except socket.timeout as e:\n        # Calculate elapsed time and log timeout\n        elapsed_time = time.perf_counter() - start_time\n        logger.warning(\n            f\"Timeout on API request {name}: took {elapsed_time:.3f}s, \"\n            f\"exceeded timeout of {self.timeout}s (port: {self.port})\"\n        )\n        raise ConnectionFailedError(\n            f\"Socket timeout during communication: {e}\",\n            error_code=\"E008\",\n            context={\"error\": str(e), \"elapsed_time\": elapsed_time},\n        ) from e\n    except socket.error as e:\n        logger.error(f\"Socket error during API request {name}: {e}\")\n        raise ConnectionFailedError(\n            f\"Socket error during communication: {e}\",\n            error_code=\"E008\",\n            context={\"error\": str(e)},\n        ) from e\n    except json.JSONDecodeError as e:\n        logger.error(f\"Invalid JSON response from API request {name}: {e}\")\n        logger.error(f\"Problematic message content: {message_str[:200]}...\")\n        logger.error(\n            f\"Message buffer state: {len(self._message_buffer)} bytes remaining\"\n        )\n\n        # Clear the message buffer to prevent cascading errors\n        if self._message_buffer:\n            logger.warning(\"Clearing message buffer due to JSON parse error\")\n            self._message_buffer = b\"\"\n\n        raise BalatroError(\n            f\"Invalid JSON response from game: {e}\",\n            error_code=\"E001\",\n            context={\"error\": str(e), \"message_preview\": message_str[:100]},\n        ) from e\n</code></pre>"},{"location":"balatrobot-api/#enums","title":"Enums","text":""},{"location":"balatrobot-api/#balatrobot.enums.State","title":"<code>balatrobot.enums.State</code>","text":"<p>Game state values representing different phases of gameplay in Balatro, from menu navigation to active card play and shop interactions.</p> Source code in <code>src/balatrobot/enums.py</code> <pre><code>@unique\nclass State(Enum):\n    \"\"\"Game state values representing different phases of gameplay in Balatro,\n    from menu navigation to active card play and shop interactions.\"\"\"\n\n    SELECTING_HAND = 1\n    HAND_PLAYED = 2\n    DRAW_TO_HAND = 3\n    GAME_OVER = 4\n    SHOP = 5\n    PLAY_TAROT = 6\n    BLIND_SELECT = 7\n    ROUND_EVAL = 8\n    TAROT_PACK = 9\n    PLANET_PACK = 10\n    MENU = 11\n    TUTORIAL = 12\n    SPLASH = 13\n    SANDBOX = 14\n    SPECTRAL_PACK = 15\n    DEMO_CTA = 16\n    STANDARD_PACK = 17\n    BUFFOON_PACK = 18\n    NEW_ROUND = 19\n</code></pre>"},{"location":"balatrobot-api/#balatrobot.enums.Actions","title":"<code>balatrobot.enums.Actions</code>","text":"<p>Bot action values corresponding to user interactions available in different game states, from card play to shop purchases and inventory management.</p> Source code in <code>src/balatrobot/enums.py</code> <pre><code>@unique\nclass Actions(Enum):\n    \"\"\"Bot action values corresponding to user interactions available in\n    different game states, from card play to shop purchases and inventory\n    management.\"\"\"\n\n    SELECT_BLIND = 1\n    SKIP_BLIND = 2\n    PLAY_HAND = 3\n    DISCARD_HAND = 4\n    END_SHOP = 5\n    REROLL_SHOP = 6\n    BUY_CARD = 7\n    BUY_VOUCHER = 8\n    BUY_BOOSTER = 9\n    SELECT_BOOSTER_CARD = 10\n    SKIP_BOOSTER_PACK = 11\n    SELL_JOKER = 12\n    USE_CONSUMABLE = 13\n    SELL_CONSUMABLE = 14\n    REARRANGE_JOKERS = 15\n    REARRANGE_CONSUMABLES = 16\n    REARRANGE_HAND = 17\n    PASS = 18\n    START_RUN = 19\n    SEND_GAMESTATE = 20\n</code></pre>"},{"location":"balatrobot-api/#balatrobot.enums.Decks","title":"<code>balatrobot.enums.Decks</code>","text":"<p>Starting deck types in Balatro, each providing unique starting conditions, card modifications, or special abilities that affect gameplay throughout the run.</p> Source code in <code>src/balatrobot/enums.py</code> <pre><code>@unique\nclass Decks(Enum):\n    \"\"\"Starting deck types in Balatro, each providing unique starting\n    conditions, card modifications, or special abilities that affect gameplay\n    throughout the run.\"\"\"\n\n    RED = \"Red Deck\"\n    BLUE = \"Blue Deck\"\n    YELLOW = \"Yellow Deck\"\n    GREEN = \"Green Deck\"\n    BLACK = \"Black Deck\"\n    MAGIC = \"Magic Deck\"\n    NEBULA = \"Nebula Deck\"\n    GHOST = \"Ghost Deck\"\n    ABANDONED = \"Abandoned Deck\"\n    CHECKERED = \"Checkered Deck\"\n    ZODIAC = \"Zodiac Deck\"\n    PAINTED = \"Painted Deck\"\n    ANAGLYPH = \"Anaglyph Deck\"\n    PLASMA = \"Plasma Deck\"\n    ERRATIC = \"Erratic Deck\"\n</code></pre>"},{"location":"balatrobot-api/#balatrobot.enums.Stakes","title":"<code>balatrobot.enums.Stakes</code>","text":"<p>Difficulty stake levels in Balatro that increase game difficulty through various modifiers and restrictions, with higher stakes providing greater challenges and rewards.</p> Source code in <code>src/balatrobot/enums.py</code> <pre><code>@unique\nclass Stakes(Enum):\n    \"\"\"Difficulty stake levels in Balatro that increase game difficulty through\n    various modifiers and restrictions, with higher stakes providing greater\n    challenges and rewards.\"\"\"\n\n    WHITE = 1\n    RED = 2\n    GREEN = 3\n    BLACK = 4\n    BLUE = 5\n    PURPLE = 6\n    ORANGE = 7\n    GOLD = 8\n</code></pre>"},{"location":"balatrobot-api/#balatrobot.enums.ErrorCode","title":"<code>balatrobot.enums.ErrorCode</code>","text":"<p>Standardized error codes used in BalatroBot API that match those defined in src/lua/api.lua for consistent error handling across the entire system.</p> Source code in <code>src/balatrobot/enums.py</code> <pre><code>@unique\nclass ErrorCode(Enum):\n    \"\"\"Standardized error codes used in BalatroBot API that match those defined in src/lua/api.lua for consistent error handling across the entire system.\"\"\"\n\n    # Protocol errors (E001-E005)\n    INVALID_JSON = \"E001\"\n    MISSING_NAME = \"E002\"\n    MISSING_ARGUMENTS = \"E003\"\n    UNKNOWN_FUNCTION = \"E004\"\n    INVALID_ARGUMENTS = \"E005\"\n\n    # Network errors (E006-E008)\n    SOCKET_CREATE_FAILED = \"E006\"\n    SOCKET_BIND_FAILED = \"E007\"\n    CONNECTION_FAILED = \"E008\"\n\n    # Validation errors (E009-E012)\n    INVALID_GAME_STATE = \"E009\"\n    INVALID_PARAMETER = \"E010\"\n    PARAMETER_OUT_OF_RANGE = \"E011\"\n    MISSING_GAME_OBJECT = \"E012\"\n\n    # Game logic errors (E013-E016)\n    DECK_NOT_FOUND = \"E013\"\n    INVALID_CARD_INDEX = \"E014\"\n    NO_DISCARDS_LEFT = \"E015\"\n    INVALID_ACTION = \"E016\"\n</code></pre>"},{"location":"balatrobot-api/#exceptions","title":"Exceptions","text":""},{"location":"balatrobot-api/#connection-and-socket-errors","title":"Connection and Socket Errors","text":""},{"location":"balatrobot-api/#balatrobot.exceptions.SocketCreateFailedError","title":"<code>balatrobot.exceptions.SocketCreateFailedError</code>","text":"<p>Socket creation failed (E006).</p>"},{"location":"balatrobot-api/#balatrobot.exceptions.SocketBindFailedError","title":"<code>balatrobot.exceptions.SocketBindFailedError</code>","text":"<p>Socket bind failed (E007).</p>"},{"location":"balatrobot-api/#balatrobot.exceptions.ConnectionFailedError","title":"<code>balatrobot.exceptions.ConnectionFailedError</code>","text":"<p>Connection failed (E008).</p>"},{"location":"balatrobot-api/#game-state-and-logic-errors","title":"Game State and Logic Errors","text":""},{"location":"balatrobot-api/#balatrobot.exceptions.InvalidGameStateError","title":"<code>balatrobot.exceptions.InvalidGameStateError</code>","text":"<p>Invalid game state for requested action (E009).</p>"},{"location":"balatrobot-api/#balatrobot.exceptions.InvalidActionError","title":"<code>balatrobot.exceptions.InvalidActionError</code>","text":"<p>Invalid action for current context (E016).</p>"},{"location":"balatrobot-api/#balatrobot.exceptions.DeckNotFoundError","title":"<code>balatrobot.exceptions.DeckNotFoundError</code>","text":"<p>Deck not found (E013).</p>"},{"location":"balatrobot-api/#balatrobot.exceptions.InvalidCardIndexError","title":"<code>balatrobot.exceptions.InvalidCardIndexError</code>","text":"<p>Invalid card index (E014).</p>"},{"location":"balatrobot-api/#balatrobot.exceptions.NoDiscardsLeftError","title":"<code>balatrobot.exceptions.NoDiscardsLeftError</code>","text":"<p>No discards remaining (E015).</p>"},{"location":"balatrobot-api/#api-and-parameter-errors","title":"API and Parameter Errors","text":""},{"location":"balatrobot-api/#balatrobot.exceptions.InvalidJSONError","title":"<code>balatrobot.exceptions.InvalidJSONError</code>","text":"<p>Invalid JSON in request (E001).</p>"},{"location":"balatrobot-api/#balatrobot.exceptions.MissingNameError","title":"<code>balatrobot.exceptions.MissingNameError</code>","text":"<p>Message missing required 'name' field (E002).</p>"},{"location":"balatrobot-api/#balatrobot.exceptions.MissingArgumentsError","title":"<code>balatrobot.exceptions.MissingArgumentsError</code>","text":"<p>Message missing required 'arguments' field (E003).</p>"},{"location":"balatrobot-api/#balatrobot.exceptions.UnknownFunctionError","title":"<code>balatrobot.exceptions.UnknownFunctionError</code>","text":"<p>Unknown function name (E004).</p>"},{"location":"balatrobot-api/#balatrobot.exceptions.InvalidArgumentsError","title":"<code>balatrobot.exceptions.InvalidArgumentsError</code>","text":"<p>Invalid arguments provided (E005).</p>"},{"location":"balatrobot-api/#balatrobot.exceptions.InvalidParameterError","title":"<code>balatrobot.exceptions.InvalidParameterError</code>","text":"<p>Invalid or missing required parameter (E010).</p>"},{"location":"balatrobot-api/#balatrobot.exceptions.ParameterOutOfRangeError","title":"<code>balatrobot.exceptions.ParameterOutOfRangeError</code>","text":"<p>Parameter value out of valid range (E011).</p>"},{"location":"balatrobot-api/#balatrobot.exceptions.MissingGameObjectError","title":"<code>balatrobot.exceptions.MissingGameObjectError</code>","text":"<p>Required game object missing (E012).</p>"},{"location":"balatrobot-api/#models","title":"Models","text":"<p>The BalatroBot API uses Pydantic models to provide type-safe data structures that exactly match the game's internal state representation. All models inherit from <code>BalatroBaseModel</code> which provides consistent validation and serialization.</p>"},{"location":"balatrobot-api/#base-model","title":"Base Model","text":""},{"location":"balatrobot-api/#balatrobot.models.BalatroBaseModel","title":"<code>balatrobot.models.BalatroBaseModel</code>","text":"<p>Base model for all BalatroBot API models.</p>"},{"location":"balatrobot-api/#request-models","title":"Request Models","text":"<p>These models define the structure for specific API requests:</p>"},{"location":"balatrobot-api/#balatrobot.models.StartRunRequest","title":"<code>balatrobot.models.StartRunRequest</code>","text":"<p>Request model for starting a new run.</p>"},{"location":"balatrobot-api/#balatrobot.models.BlindActionRequest","title":"<code>balatrobot.models.BlindActionRequest</code>","text":"<p>Request model for skip or select blind actions.</p>"},{"location":"balatrobot-api/#balatrobot.models.HandActionRequest","title":"<code>balatrobot.models.HandActionRequest</code>","text":"<p>Request model for playing hand or discarding cards.</p>"},{"location":"balatrobot-api/#balatrobot.models.ShopActionRequest","title":"<code>balatrobot.models.ShopActionRequest</code>","text":"<p>Request model for shop actions.</p>"},{"location":"balatrobot-api/#game-state-models","title":"Game State Models","text":"<p>The game state models provide comprehensive access to all Balatro game information, structured hierarchically to match the Lua API:</p>"},{"location":"balatrobot-api/#root-game-state","title":"Root Game State","text":""},{"location":"balatrobot-api/#balatrobot.models.G","title":"<code>balatrobot.models.G</code>","text":"<p>Root game state response matching G in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.G.state_enum","title":"<code>state_enum</code>  <code>property</code>","text":"<p>Get the state as an enum value.</p>"},{"location":"balatrobot-api/#balatrobot.models.G.convert_empty_list_to_none_for_hand","title":"<code>convert_empty_list_to_none_for_hand(v)</code>  <code>classmethod</code>","text":"<p>Convert empty list to None for hand field.</p>"},{"location":"balatrobot-api/#game-information","title":"Game Information","text":""},{"location":"balatrobot-api/#balatrobot.models.GGame","title":"<code>balatrobot.models.GGame</code>","text":"<p>Game state matching GGame in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.GGame.convert_empty_list_to_dict","title":"<code>convert_empty_list_to_dict(v)</code>  <code>classmethod</code>","text":"<p>Convert empty list to empty dict.</p>"},{"location":"balatrobot-api/#balatrobot.models.GGame.convert_empty_list_to_none","title":"<code>convert_empty_list_to_none(v)</code>  <code>classmethod</code>","text":"<p>Convert empty list to None for optional nested objects.</p>"},{"location":"balatrobot-api/#balatrobot.models.GGameCurrentRound","title":"<code>balatrobot.models.GGameCurrentRound</code>","text":"<p>Current round info matching GGameCurrentRound in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.GGameCurrentRound.convert_empty_list_to_dict","title":"<code>convert_empty_list_to_dict(v)</code>  <code>classmethod</code>","text":"<p>Convert empty list to empty dict.</p>"},{"location":"balatrobot-api/#balatrobot.models.GGameLastBlind","title":"<code>balatrobot.models.GGameLastBlind</code>","text":"<p>Last blind info matching GGameLastBlind in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.GGamePreviousRound","title":"<code>balatrobot.models.GGamePreviousRound</code>","text":"<p>Previous round info matching GGamePreviousRound in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.GGameProbabilities","title":"<code>balatrobot.models.GGameProbabilities</code>","text":"<p>Game probabilities matching GGameProbabilities in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.GGamePseudorandom","title":"<code>balatrobot.models.GGamePseudorandom</code>","text":"<p>Pseudorandom data matching GGamePseudorandom in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.GGameRoundBonus","title":"<code>balatrobot.models.GGameRoundBonus</code>","text":"<p>Round bonus matching GGameRoundBonus in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.GGameRoundScores","title":"<code>balatrobot.models.GGameRoundScores</code>","text":"<p>Round scores matching GGameRoundScores in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.GGameSelectedBack","title":"<code>balatrobot.models.GGameSelectedBack</code>","text":"<p>Selected deck info matching GGameSelectedBack in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.GGameShop","title":"<code>balatrobot.models.GGameShop</code>","text":"<p>Shop configuration matching GGameShop in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.GGameStartingParams","title":"<code>balatrobot.models.GGameStartingParams</code>","text":"<p>Starting parameters matching GGameStartingParams in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.GGameTags","title":"<code>balatrobot.models.GGameTags</code>","text":"<p>Game tags model matching GGameTags in Lua types.</p>"},{"location":"balatrobot-api/#hand-management","title":"Hand Management","text":""},{"location":"balatrobot-api/#balatrobot.models.GHand","title":"<code>balatrobot.models.GHand</code>","text":"<p>Hand structure matching GHand in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.GHandCards","title":"<code>balatrobot.models.GHandCards</code>","text":"<p>Hand card matching GHandCards in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.GHandCardsBase","title":"<code>balatrobot.models.GHandCardsBase</code>","text":"<p>Hand card base properties matching GHandCardsBase in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.GHandCardsBase.convert_int_to_string","title":"<code>convert_int_to_string(v)</code>  <code>classmethod</code>","text":"<p>Convert integer values to strings.</p>"},{"location":"balatrobot-api/#balatrobot.models.GHandCardsConfig","title":"<code>balatrobot.models.GHandCardsConfig</code>","text":"<p>Hand card configuration matching GHandCardsConfig in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.GHandCardsConfigCard","title":"<code>balatrobot.models.GHandCardsConfigCard</code>","text":"<p>Hand card config card data matching GHandCardsConfigCard in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.GHandConfig","title":"<code>balatrobot.models.GHandConfig</code>","text":"<p>Hand configuration matching GHandConfig in Lua types.</p>"},{"location":"balatrobot-api/#joker-information","title":"Joker Information","text":""},{"location":"balatrobot-api/#balatrobot.models.GJokersCards","title":"<code>balatrobot.models.GJokersCards</code>","text":"<p>Joker card matching GJokersCards in Lua types.</p>"},{"location":"balatrobot-api/#balatrobot.models.GJokersCardsConfig","title":"<code>balatrobot.models.GJokersCardsConfig</code>","text":"<p>Joker card configuration matching GJokersCardsConfig in Lua types.</p>"},{"location":"balatrobot-api/#communication-models","title":"Communication Models","text":"<p>These models handle the communication protocol between your bot and the game:</p>"},{"location":"balatrobot-api/#balatrobot.models.APIRequest","title":"<code>balatrobot.models.APIRequest</code>","text":"<p>Model for API requests sent to the game.</p>"},{"location":"balatrobot-api/#balatrobot.models.APIResponse","title":"<code>balatrobot.models.APIResponse</code>","text":"<p>Model for API responses from the game.</p>"},{"location":"balatrobot-api/#balatrobot.models.ErrorResponse","title":"<code>balatrobot.models.ErrorResponse</code>","text":"<p>Model for API error responses matching Lua ErrorResponse.</p>"},{"location":"balatrobot-api/#balatrobot.models.JSONLLogEntry","title":"<code>balatrobot.models.JSONLLogEntry</code>","text":"<p>Model for JSONL log entries that record game actions.</p>"},{"location":"balatrobot-api/#usage-examples","title":"Usage Examples","text":"<p>For practical implementation examples:</p> <ul> <li>Follow the Developing Bots guide for complete bot setup</li> <li>Understand the underlying Protocol API for advanced usage</li> <li>Reference the Installation guide for environment setup</li> </ul>"},{"location":"contributing/","title":"Contributing to BalatroBot","text":"<p>Welcome to BalatroBot! We're excited that you're interested in contributing to this Python framework and Lua mod for creating automated bots to play Balatro.</p> <p>BalatroBot uses a dual-architecture approach with a Python framework that communicates with a Lua mod running inside Balatro via TCP sockets. This allows for real-time bot automation and game state analysis.</p>"},{"location":"contributing/#project-status-priorities","title":"Project Status &amp; Priorities","text":"<p>We track all development work using the BalatroBot GitHub Project. This is the best place to see current priorities, ongoing work, and opportunities for contribution.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>Before contributing, ensure you have:</p> <ul> <li>Balatro: Version 1.0.1o-FULL</li> <li>SMODS (Steamodded): Version 1.0.0-beta-0711a or newer</li> <li>Python: 3.13+ (managed via uv)</li> <li>uv: Python package manager (Installation Guide)</li> <li>OS: macOS, Linux. Windows is not currently supported</li> <li>DebugPlus (optional): useful for Lua API development and debugging</li> </ul>"},{"location":"contributing/#development-environment-setup","title":"Development Environment Setup","text":"<ol> <li> <p>Fork and Clone</p> <pre><code>git clone https://github.com/YOUR_USERNAME/balatrobot.git\ncd balatrobot\n</code></pre> </li> <li> <p>Install Dependencies</p> <pre><code>make install-dev\n</code></pre> </li> <li> <p>Start Balatro with Mods</p> <pre><code>./balatro.sh -p 12346\n</code></pre> </li> <li> <p>Verify Balatro is Running</p> <pre><code># Check if Balatro is running\n./balatro.sh --status\n\n# Monitor startup logs\ntail -n 100 logs/balatro_12346.log\n</code></pre> <p>Look for these success indicators:</p> <ul> <li>\"BalatrobotAPI initialized\"</li> <li>\"BalatroBot loaded - version X.X.X\"</li> <li>\"TCP socket created on port 12346\"</li> </ul> </li> </ol>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":""},{"location":"contributing/#types-of-contributions-welcome","title":"Types of Contributions Welcome","text":"<ul> <li>Bug Fixes: Issues tracked in our GitHub project</li> <li>Feature Development: New bot strategies, API enhancements</li> <li>Performance Improvements: Optimization of TCP communication or game interaction</li> <li>Documentation: Improvements to guides, API documentation, or examples</li> <li>Testing: Additional test coverage, edge case handling</li> </ul>"},{"location":"contributing/#contribution-workflow","title":"Contribution Workflow","text":"<ol> <li> <p>Check Issues First (Highly Encouraged)</p> <ul> <li>Browse the BalatroBot GitHub Project</li> <li>Comment on issues you'd like to work on</li> <li>Create new issues for bugs or feature requests</li> </ul> </li> <li> <p>Fork &amp; Branch</p> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> </li> <li> <p>Make Changes</p> <ul> <li>Follow our code style guidelines (see below)</li> <li>Add tests for new functionality</li> <li>Update documentation as needed</li> </ul> </li> <li> <p>Create Pull Request</p> <ul> <li>Important: Enable \"Allow edits from maintainers\" when creating your PR</li> <li>Link to related issues</li> <li>Provide clear description of changes</li> <li>Include tests for new functionality</li> </ul> </li> </ol>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<p>We highly encourage following Conventional Commits format:</p> <pre><code>feat(api): add new game state detection\nfix(tcp): resolve connection timeout issues\ndocs(readme): update setup instructions\ntest(api): add shop booster validation tests\n</code></pre>"},{"location":"contributing/#development-testing","title":"Development &amp; Testing","text":""},{"location":"contributing/#makefile-commands","title":"Makefile Commands","text":"<p>BalatroBot includes a comprehensive Makefile that provides a convenient interface for all development tasks. Use <code>make help</code> to see all available commands:</p> <pre><code># Show all available commands with descriptions\nmake help\n</code></pre>"},{"location":"contributing/#installation-setup","title":"Installation &amp; Setup","text":"<pre><code>make install        # Install package dependencies\nmake install-dev    # Install with development dependencies\n</code></pre>"},{"location":"contributing/#code-quality-formatting","title":"Code Quality &amp; Formatting","text":"<pre><code>make lint           # Run ruff linter (check only)\nmake lint-fix       # Run ruff linter with auto-fixes\nmake format         # Run ruff formatter and stylua\nmake format-md      # Run markdown formatter\nmake typecheck      # Run type checker\nmake quality        # Run all code quality checks\nmake dev            # Quick development check (format + lint + typecheck, no tests)\n</code></pre>"},{"location":"contributing/#testing-requirements","title":"Testing Requirements","text":""},{"location":"contributing/#testing-with-makefile","title":"Testing with Makefile","text":"<pre><code>make test           # Run tests with single instance (auto-starts if needed)\nmake test-parallel  # Run tests on 4 instances (auto-starts if needed)\nmake test-teardown  # Kill all Balatro instances\n\n# Complete workflow including tests\nmake all            # Run format + lint + typecheck + test\n</code></pre> <p>The testing system automatically handles Balatro instance management:</p> <ul> <li><code>make test</code>: Runs tests with a single instance, auto-starting if needed</li> <li><code>make test-parallel</code>: Runs tests on 4 instances for ~4x speedup, auto-starting if needed</li> <li><code>make test-teardown</code>: Cleans up all instances when done</li> </ul> <p>Both test commands keep instances running after completion for faster subsequent runs.</p>"},{"location":"contributing/#using-checkpoints-for-test-setup","title":"Using Checkpoints for Test Setup","text":"<p>The checkpointing system allows you to save and load specific game states, significantly speeding up test setup:</p> <p>Creating Test Checkpoints:</p> <pre><code># Create a checkpoint at a specific game state\npython scripts/create_test_checkpoint.py shop tests/lua/endpoints/checkpoints/shop_state.jkr\npython scripts/create_test_checkpoint.py blind_select tests/lua/endpoints/checkpoints/blind_select.jkr\npython scripts/create_test_checkpoint.py in_game tests/lua/endpoints/checkpoints/in_game.jkr\n</code></pre> <p>Using Checkpoints in Tests:</p> <pre><code># In conftest.py or test files\nfrom ..conftest import prepare_checkpoint\n\ndef setup_and_teardown(tcp_client):\n    # Load a checkpoint directly (no restart needed!)\n    checkpoint_path = Path(__file__).parent / \"checkpoints\" / \"shop_state.jkr\"\n    game_state = prepare_checkpoint(tcp_client, checkpoint_path)\n    assert game_state[\"state\"] == State.SHOP.value\n</code></pre> <p>Benefits of Checkpoints:</p> <ul> <li>Faster Tests: Skip manual game setup steps (particularly helpful for edge cases)</li> <li>Consistency: Always start from exact same state</li> <li>Reusability: Share checkpoints across multiple tests</li> <li>No Restarts: Uses <code>load_save</code> API to load directly from any game state</li> </ul> <p>Python Client Methods:</p> <pre><code>from balatrobot import BalatroClient\n\nwith BalatroClient() as client:\n    # Save current game state as checkpoint\n    client.save_checkpoint(\"tests/fixtures/my_state.jkr\")\n\n    # Load a checkpoint for testing\n    save_path = client.prepare_save(\"tests/fixtures/my_state.jkr\")\n    game_state = client.load_save(save_path)\n</code></pre> <p>Manual Setup for Advanced Testing:</p> <pre><code># Check/manage Balatro instances\n./balatro.sh --status                   # Show running instances\n./balatro.sh --kill                     # Kill all instances\n\n# Start instances manually\n./balatro.sh -p 12346 -p 12347          # Two instances\n./balatro.sh --headless --fast -p 12346 -p 12347 -p 12348 -p 12349  # Full setup\n./balatro.sh --audio -p 12346                                    # With audio enabled\n\n# Manual parallel testing\npytest -n 4 --port 12346 --port 12347 --port 12348 --port 12349 tests/lua/\n</code></pre> <p>Performance Modes:</p> <ul> <li><code>--headless</code>: No graphics, ideal for servers</li> <li><code>--fast</code>: 10x speed, disabled effects, optimal for testing</li> <li><code>--audio</code>: Enable audio (disabled by default for performance)</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<pre><code>make docs-serve     # Serve documentation locally\nmake docs-build     # Build documentation\nmake docs-clean     # Clean built documentation\n</code></pre>"},{"location":"contributing/#build-maintenance","title":"Build &amp; Maintenance","text":"<pre><code>make build          # Build package for distribution\nmake clean          # Clean build artifacts and caches\n</code></pre>"},{"location":"contributing/#technical-guidelines","title":"Technical Guidelines","text":""},{"location":"contributing/#python-development","title":"Python Development","text":"<ul> <li>Style: Follow modern Python 3.13+ patterns</li> <li>Type Hints: Use pipe operator for unions (<code>str | int | None</code>)</li> <li>Type Aliases: Use <code>type</code> statement</li> <li>Docstrings: Google-style without type information (types in annotations)</li> <li>Generics: Modern syntax (<code>class Container[T]:</code>)</li> </ul>"},{"location":"contributing/#lua-development","title":"Lua Development","text":"<ul> <li>Focus Area: Primary development is on <code>src/lua/api.lua</code></li> <li>Communication: TCP protocol on port 12346</li> <li>Debugging: Use DebugPlus mod for enhanced debugging capabilities</li> </ul>"},{"location":"contributing/#environment-variables","title":"Environment Variables","text":"<p>Configure BalatroBot behavior with these environment variables:</p> <ul> <li><code>BALATROBOT_HEADLESS=1</code>: Disable graphics for server environments</li> <li><code>BALATROBOT_FAST=1</code>: Enable 10x speed with disabled effects for testing</li> <li><code>BALATROBOT_AUDIO=1</code>: Enable audio (disabled by default for performance)</li> <li><code>BALATROBOT_PORT</code>: TCP communication port (default: \"12346\")</li> </ul>"},{"location":"contributing/#communication-community","title":"Communication &amp; Community","text":""},{"location":"contributing/#preferred-channels","title":"Preferred Channels","text":"<ul> <li>GitHub Issues: Primary communication for bugs, features, and project coordination</li> <li>Discord: Join us at the Balatro Discord for real-time discussions</li> </ul> <p>Happy contributing!</p>"},{"location":"developing-bots/","title":"Developing Bots","text":"<p>BalatroBot allows you to create automated players (bots) that can play Balatro by implementing decision-making logic in Python. Your bot communicates with the game through a TCP socket connection, sending actions to perform and receiving back the game state.</p>"},{"location":"developing-bots/#bot-architecture","title":"Bot Architecture","text":"<p>A bot is a finite state machine that implements a sequence of actions to play the game. The bot can be in one state at a time and has access to a set of functions that can move the bot to other states.</p> State Description Functions <code>MENU</code> The main menu <code>start_run</code> <code>BLIND_SELECT</code> Selecting or skipping the blind <code>skip_or_select_blind</code> <code>SELECTING_HAND</code> Selecting cards to play or discard <code>play_hand_or_discard</code>, <code>rearrange_hand</code> <code>ROUND_EVAL</code> Evaluating the round outcome and cashing out <code>cash_out</code> <code>SHOP</code> Buy items and move to the next round <code>shop</code> <code>GAME_OVER</code> Game has ended \u2013 <p>Developing a bot boils down to providing the action name and its parameters for each state.</p>"},{"location":"developing-bots/#state-diagram","title":"State Diagram","text":"<p>The following diagram illustrates the possible states of the game and how the functions can be used to move the bot between them:</p> <ul> <li>Start (\u25c9) and End (\u29be) states</li> <li>States are written in uppercase (e.g., <code>MENU</code>, <code>BLIND_SELECT</code>, ...)</li> <li>Functions are written in lowercase (e.g., <code>start_run</code>, <code>skip_or_select_blind</code>, ...)</li> <li>Function parameters are written in italics (e.g., <code>action = play_hand</code>). Not all parameters are reported in the diagram.</li> <li>Comments are reported in parentheses (e.g., <code>(win round)</code>, <code>(lose round)</code>).</li> <li>Abstract groups are written with capital letters (e.g., <code>Run</code>, <code>Round</code>, ...)</li> </ul> <pre><code>stateDiagram-v2\n  direction TB\n\n  BLIND_SELECT_1:BLIND_SELECT\n\n  [*] --&gt; MENU: go_to_menu\n  MENU --&gt; BLIND_SELECT: start_run\n\n  state Run{\n\n    BLIND_SELECT --&gt; skip_or_select_blind\n\n    skip_or_select_blind --&gt; BLIND_SELECT: *action = skip*&lt;/br&gt;(small or big blind)\n    skip_or_select_blind --&gt; SELECTING_HAND: *action = select*\n\n    state Round {\n      SELECTING_HAND --&gt; play_hand_or_discard\n\n      play_hand_or_discard --&gt; SELECTING_HAND: *action = play_hand*\n      play_hand_or_discard --&gt; SELECTING_HAND: *action = discard*\n      play_hand_or_discard --&gt; ROUND_EVAL: *action = play_hand*&lt;br/&gt;(win round)\n      play_hand_or_discard --&gt; GAME_OVER: *action = play_hand*&lt;br/&gt;(lose round)\n    }\n\n    state RoundEval {\n      ROUND_EVAL --&gt; SHOP: *cash_out*\n    }\n\n    state Shop {\n      SHOP --&gt; shop\n      shop --&gt; BLIND_SELECT_1: *action = next_round*\n    }\n\n    state GameOver {\n      GAME_OVER --&gt; [*]\n    }\n\n  }\n\n  state skip_or_select_blind &lt;&lt;choice&gt;&gt;\n  state play_hand_or_discard &lt;&lt;choice&gt;&gt;\n  state shop &lt;&lt;choice&gt;&gt;</code></pre>"},{"location":"developing-bots/#development-environment-setup","title":"Development Environment Setup","text":"<p>The BalatroBot project provides a complete development environment with all necessary tools and resources for developing bots.</p>"},{"location":"developing-bots/#environment-setup","title":"Environment Setup","text":"<p>Before developing or running bots, you need to set up the development environment by configuring the <code>.envrc</code> file:</p> WindowsMacOSLinux <pre><code>cd %AppData%/Balatro/Mods/balatrobot\ncopy .envrc.example .envrc\n.envrc\n</code></pre> <pre><code>cd \"/Users/$USER/Library/Application Support/Balatro/Mods/balatrobot\"\ncp .envrc.example .envrc\nsource .envrc\n</code></pre> <pre><code>cd ~/.local/share/Steam/steamapps/compatdata/2379780/pfx/drive_c/users/steamuser/AppData/Roaming/Balatro/Mods/balatrobot\ncp .envrc.example .envrc\nsource .envrc\n</code></pre> <p>Always Source Environment</p> <p>Remember to source the <code>.envrc</code> file every time you start a new terminal session before developing or running bots. The environment variables are essential for proper bot functionality.</p> <p>Automatic Environment Loading with direnv</p> <p>For a better development experience, consider using direnv to automatically load and unload environment variables when entering and leaving the project directory.</p> <p>After installing direnv and hooking it into your shell:</p> <pre><code># Allow direnv to load the .envrc file automatically\ndirenv allow .\n</code></pre> <p>This eliminates the need to manually source <code>.envrc</code> every time you work on the project.</p>"},{"location":"developing-bots/#bot-file-location","title":"Bot File Location","text":"<p>When developing new bots, place your files in the <code>bots/</code> directory using one of these recommended patterns:</p> <ul> <li>Single file bots: <code>bots/my_new_bot.py</code></li> <li>Complex bots: <code>bots/my_new_bot/main.py</code> (for bots with multiple modules)</li> </ul>"},{"location":"developing-bots/#next-steps","title":"Next Steps","text":"<p>After setting up your development environment:</p> <ul> <li>Explore the BalatroBot API for detailed client and model documentation</li> <li>Learn about the underlying Protocol API for TCP communication details</li> </ul>"},{"location":"gymnasium/","title":"Gymnasium MDP Integration","text":"<p>BalatroBot provides a Gymnasium-compatible environment for training reinforcement learning agents to play Balatro.</p>"},{"location":"gymnasium/#overview","title":"Overview","text":"<p>The <code>BalatroEnv</code> class wraps the BalatroBot client in a standard Gymnasium interface, providing:</p> <ul> <li>Observation Space: Dictionary containing game state features</li> <li>Action Space: Discrete actions mapped to game commands</li> <li>Reward Function: Configurable rewards based on game progress</li> <li>Episode Management: Automatic reset and termination handling</li> </ul>"},{"location":"gymnasium/#installation","title":"Installation","text":"<p>Ensure you have the required dependencies:</p> <pre><code>pip install gymnasium numpy\n# or with uv\nuv add gymnasium numpy\n</code></pre>"},{"location":"gymnasium/#basic-usage","title":"Basic Usage","text":"<pre><code>from balatrobot import BalatroEnv\nfrom balatrobot.enums import Decks, Stakes\n\n# Create the environment\nenv = BalatroEnv(\n    port=12346,\n    deck=Decks.RED.value,\n    stake=Stakes.WHITE.value,\n    seed=\"SEED123\",\n    max_steps=1000,\n    render_mode=\"human\",\n)\n\n# Reset to start a new episode\nobservation, info = env.reset()\n\n# Run an episode\ndone = False\ntotal_reward = 0\n\nwhile not done:\n    # Select an action (random for this example)\n    action = env.action_space.sample()\n\n    # Execute the action\n    observation, reward, terminated, truncated, info = env.step(action)\n\n    total_reward += reward\n    done = terminated or truncated\n\n    # Optionally render\n    env.render()\n\nprint(f\"Episode finished with total reward: {total_reward}\")\nenv.close()\n</code></pre>"},{"location":"gymnasium/#mdp-structure","title":"MDP Structure","text":""},{"location":"gymnasium/#state-space","title":"State Space","text":"<p>The MDP follows the game's natural state transitions:</p> <ol> <li>MENU \u2192 <code>start_run()</code> \u2192 BLIND_SELECT</li> <li>BLIND_SELECT \u2192 <code>skip_or_select_blind()</code> \u2192 SELECTING_HAND</li> <li>SELECTING_HAND \u2192 <code>play_hand_or_discard()</code> \u2192 HAND_PLAYED/DRAW_TO_HAND</li> <li>ROUND_EVAL \u2192 <code>cash_out()</code> \u2192 SHOP</li> <li>SHOP \u2192 <code>shop(next_round)</code> \u2192 BLIND_SELECT</li> <li>Terminal states: GAME_OVER or max steps reached</li> </ol>"},{"location":"gymnasium/#observation-space","title":"Observation Space","text":"<p>The observation is a dictionary with the following keys:</p> Key Type Range Description <code>state</code> float32[1] [0, 27] Current game state enum value <code>chips</code> float32[1] [0, \u221e) Current chip count <code>dollars</code> float32[1] [0, \u221e) Current money amount <code>round</code> float32[1] [0, \u221e) Current round number <code>hands_left</code> float32[1] [0, 10] Hands remaining in round <code>discards_left</code> float32[1] [0, 10] Discards remaining in round <code>hand_size</code> float32[1] [0, 20] Number of cards in hand <code>joker_count</code> float32[1] [0, 10] Number of active jokers <code>deck_vector</code> float32[52] {0, 1} Fixed 52-card composition (1 per card)"},{"location":"gymnasium/#action-space-policies","title":"Action Space &amp; Policies","text":"<p>The environment still exposes a <code>Discrete(64)</code> Gym action space for future compatibility, but the current policies operate internally (the external action argument is ignored for now). Built-in policies are selected through the <code>policy</code> parameter:</p> <ol> <li><code>random</code> \u2013 Always selects the blind, then randomly chooses to play or discard up to five cards each turn.</li> <li><code>greedy</code> \u2013 Evaluates every 5-card combination and always plays the highest-ranked poker hand (no discarding).</li> <li><code>hybrid</code> \u2013 Plays the best hand if its rank is above Three of a Kind; otherwise, if there is a 4-card flush draw, discards off-suit cards to fish for the flush, falling back to the best hand when no draw exists.</li> </ol> <p>This structure allows apples-to-apples comparisons between baseline policies while we work toward re-exposing the action space for external agents.</p>"},{"location":"gymnasium/#reward-function","title":"Reward Function","text":"<p>The default reward function is shaped specifically for Balatro progression:</p> <ol> <li>Chips gained: <code>+0.5 \u00d7 chips_delta</code></li> <li>Money gained: <code>+1.0 \u00d7 dollars_delta</code></li> <li>Round advancement: <code>+10 \u00d7 round_number</code> (round 1: +10, round 2: +20, ...)</li> <li>Ante advancement: <code>+50 + 50 \u00d7 ante_number</code> (ante 1: +100, ante 2: +150, ...)</li> </ol> <p>No per-step penalty is currently applied. Customize the reward signal by subclassing <code>BalatroEnv</code> and overriding <code>_calculate_reward()</code>.</p> <p>You can customize the reward function by subclassing <code>BalatroEnv</code> and overriding <code>_calculate_reward()</code>.</p>"},{"location":"gymnasium/#configuration","title":"Configuration","text":""},{"location":"gymnasium/#environment-parameters","title":"Environment Parameters","text":"<pre><code>BalatroEnv(\n    port=12346,              # BalatroBot API port\n    deck=\"Red Deck\",         # Starting deck\n    stake=1,                 # Difficulty (1-8)\n    seed=None,              # Optional seed for reproducibility\n    max_steps=1000,         # Maximum steps per episode\n    render_mode=None,       # \"human\" or \"rgb_array\"\n    policy=\"greedy\",         # \"random\", \"greedy\", or \"hybrid\"\n)\n</code></pre>"},{"location":"gymnasium/#render-modes","title":"Render Modes","text":"<ul> <li><code>\"human\"</code>: Prints game state to console</li> <li><code>\"rgb_array\"</code>: Returns screenshot as numpy array (requires PIL)</li> <li><code>None</code>: No rendering</li> </ul>"},{"location":"gymnasium/#advanced-usage","title":"Advanced Usage","text":""},{"location":"gymnasium/#custom-reward-function","title":"Custom Reward Function","text":"<pre><code>class CustomBalatroEnv(BalatroEnv):\n    def _calculate_reward(self) -&gt; float:\n        \"\"\"Custom reward focusing on money accumulation.\"\"\"\n        if self.current_state is None or self.current_state.game is None:\n            return 0.0\n\n        reward = 0.0\n        game = self.current_state.game\n\n        # Heavy reward for money\n        dollars_gained = game.dollars - self.last_dollars\n        reward += dollars_gained * 1.0\n\n        # Bonus for jokers\n        if isinstance(self.current_state.jokers, list):\n            reward += len(self.current_state.jokers) * 0.5\n\n        # Update tracking\n        self.last_dollars = game.dollars\n\n        return reward\n</code></pre>"},{"location":"gymnasium/#integration-with-rl-libraries","title":"Integration with RL Libraries","text":""},{"location":"gymnasium/#stable-baselines3","title":"Stable-Baselines3","text":"<pre><code>from stable_baselines3 import PPO\nfrom balatrobot import BalatroEnv\n\n# Create environment\nenv = BalatroEnv(max_steps=500)\n\n# Train PPO agent\nmodel = PPO(\"MultiInputPolicy\", env, verbose=1)\nmodel.learn(total_timesteps=100_000)\n\n# Save model\nmodel.save(\"balatro_ppo\")\n\n# Test trained agent\nobs, info = env.reset()\nfor _ in range(1000):\n    action, _states = model.predict(obs, deterministic=True)\n    obs, reward, terminated, truncated, info = env.step(action)\n    if terminated or truncated:\n        break\n\nenv.close()\n</code></pre>"},{"location":"gymnasium/#ray-rllib","title":"Ray RLlib","text":"<pre><code>from ray.rllib.algorithms.ppo import PPOConfig\nfrom balatrobot import BalatroEnv\n\n# Configure algorithm\nconfig = (\n    PPOConfig()\n    .environment(BalatroEnv, env_config={\n        \"port\": 12346,\n        \"max_steps\": 500,\n    })\n    .framework(\"torch\")\n    .training(lr=3e-4)\n)\n\n# Build and train\nalgo = config.build()\nfor i in range(100):\n    result = algo.train()\n    print(f\"Iteration {i}: reward={result['episode_reward_mean']}\")\n\nalgo.save(\"balatro_rllib\")\n</code></pre>"},{"location":"gymnasium/#error-handling","title":"Error Handling","text":"<p>The environment handles common errors gracefully:</p> <ul> <li>Connection failures: Environment will attempt to reconnect on reset</li> <li>Invalid actions: Logged as warnings, game state retrieved</li> <li>Game crashes: Episode terminates with appropriate reward</li> </ul>"},{"location":"gymnasium/#debugging","title":"Debugging","text":"<p>Enable debug logging to see detailed information:</p> <pre><code>import logging\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(\"balatrobot\")\nlogger.setLevel(logging.DEBUG)\n\nenv = BalatroEnv()\n# ... use environment\n</code></pre>"},{"location":"gymnasium/#limitations","title":"Limitations","text":"<ol> <li> <p>Simplified Action Space: The current action space uses a simplified encoding. Full Balatro gameplay would require more complex action representations.</p> </li> <li> <p>Observation Features: The observation space captures core game state but doesn't include all available information (e.g., specific card details, joker effects).</p> </li> <li> <p>Real-time Constraint: The environment requires a running Balatro game instance, making training slower than simulated environments.</p> </li> <li> <p>Partial Observability: Some game information (future card draws, exact probabilities) is not observable.</p> </li> </ol>"},{"location":"gymnasium/#future-enhancements","title":"Future Enhancements","text":"<ul> <li>Action Masking: Expose valid actions for current state</li> <li>Hierarchical Actions: Multi-level action space for shop and card selection</li> <li>Rich Observations: Include card embeddings and joker descriptions</li> <li>Vectorized Environments: Support for parallel game instances</li> <li>Curriculum Learning: Progressive difficulty through stake levels</li> </ul>"},{"location":"gymnasium/#examples","title":"Examples","text":"<p>See the following files for complete examples:</p> <ul> <li><code>bots/example_mdp.py</code>: Basic random agent</li> <li><code>tests/balatrobot/test_env.py</code>: Unit tests and usage patterns</li> </ul>"},{"location":"gymnasium/#troubleshooting","title":"Troubleshooting","text":"<p>Issue: Environment hangs on reset</p> <p>Solution: Ensure Balatro is running with BalatroBot mod loaded and listening on the specified port.</p> <p>Issue: Actions seem ineffective</p> <p>Solution: Check that actions match the current game state. Enable debug logging to see action execution details.</p> <p>Issue: Episode terminates immediately</p> <p>Solution: Check the <code>max_steps</code> parameter and ensure the game isn't already in a terminal state.</p>"},{"location":"gymnasium/#references","title":"References","text":"<ul> <li>Gymnasium Documentation</li> <li>BalatroBot API Reference</li> <li>Game State Models</li> </ul>"},{"location":"installation/","title":"Installation Guide","text":"<p>This guide will walk you through installing and setting up BalatroBot.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing BalatroBot, ensure you have:</p> <ul> <li>balatro: Steam version (&gt;= 1.0.1)</li> <li>git: for cloning the repository</li> <li>uv: for managing Python installations, environments, and dependencies</li> <li>lovely: for injecting Lua code into Balatro (&gt;= 0.8.0)</li> <li>steamodded: for loading and injecting mods (&gt;= 1.0.0)</li> </ul>"},{"location":"installation/#step-1-install-balatrobot","title":"Step 1: Install BalatroBot","text":"<p>BalatroBot is installed like any other Steamodded mod.</p> WindowsMacOSLinux <pre><code>cd %AppData%/Balatro\nmkdir -p Mods\ncd Mods\ngit clone https://github.com/coder/balatrobot.git\n</code></pre> <pre><code>cd \"/Users/$USER/Library/Application Support/Balatro\"\nmkdir -p Mods\ncd Mods\ngit clone https://github.com/coder/balatrobot.git\n</code></pre> <pre><code>cd ~/.local/share/Steam/steamapps/compatdata/2379780/pfx/drive_c/users/steamuser/AppData/Roaming/Balatro\nmkdir -p Mods\ncd Mods\ngit clone https://github.com/coder/balatrobot.git\n</code></pre> <p>Tip</p> <p>You can also clone the repository somewhere else and then provide a symlink to the <code>balatrobot</code> directory in the <code>Mods</code> directory.</p> WindowsMacOSLinux <pre><code># Clone repository to a custom location\ncd C:\\your\\custom\\path\ngit clone https://github.com/coder/balatrobot.git\n\n# Create symlink in Mods directory\ncd %AppData%/Balatro/Mods\nmklink /D balatrobot C:\\your\\custom\\path\\balatrobot\n</code></pre> <pre><code># Clone repository to a custom location\ncd /your/custom/path\ngit clone https://github.com/coder/balatrobot.git\n\n# Create symlink in Mods directory\ncd \"/Users/$USER/Library/Application Support/Balatro/Mods\"\nln -s /your/custom/path/balatrobot balatrobot\n</code></pre> <pre><code># Clone repository to a custom location\ncd /your/custom/path\ngit clone https://github.com/coder/balatrobot.git\n\n# Create symlink in Mods directory\ncd ~/.local/share/Steam/steamapps/compatdata/2379780/pfx/drive_c/users/steamuser/AppData/Roaming/Balatro/Mods\nln -s /your/custom/path/balatrobot balatrobot\n</code></pre> Update BalatroBot <p>Updating BalatroBot is as simple as pulling the latest changes from the repository.</p> WindowsMacOSLinux <pre><code>cd %AppData%/Balatro/Mods/balatrobot\ngit pull\n</code></pre> <pre><code>cd \"/Users/$USER/Library/Application Support/Balatro/Mods/balatrobot\"\ngit pull\n</code></pre> <pre><code>cd ~/.local/share/Steam/steamapps/compatdata/2379780/pfx/drive_c/users/steamuser/AppData/Roaming/Balatro/Mods/balatrobot\ngit pull\n</code></pre> Uninstall BalatroBot <p>Simply delete the balatrobot mod directory.</p> WindowsMacOSLinux <pre><code>cd %AppData%/Balatro/Mods\nrmdir /S /Q balatrobot\n</code></pre> <pre><code>cd \"/Users/$USER/Library/Application Support/Balatro/Mods\"\nrm -rf balatrobot\n</code></pre> <pre><code>cd ~/.local/share/Steam/steamapps/compatdata/2379780/pfx/drive_c/users/steamuser/AppData/Roaming/Balatro/Mods\nrm -rf balatrobot\n</code></pre>"},{"location":"installation/#step-2-set-up-python-environment","title":"Step 2: Set Up Python Environment","text":"<p>Uv takes care of managing Python installations, virtual environment creation, and dependency installation. To set up the Python environment for running BalatroBot bots, simply run:</p> WindowsMacOSLinux <pre><code>cd %AppData%/Balatro/Mods/balatrobot\nuv sync\n</code></pre> <pre><code>cd \"/Users/$USER/Library/Application Support/Balatro/Mods/balatrobot\"\nuv sync\n</code></pre> <pre><code>cd ~/.local/share/Steam/steamapps/compatdata/2379780/pfx/drive_c/users/steamuser/AppData/Roaming/Balatro/Mods/balatrobot\nuv sync\n</code></pre> <p>The same command can be used to update the Python environment and dependencies in the future.</p> Remove Python Environment <p>To uninstall the Python environment and dependencies, simply remove the <code>.venv</code> directory.</p> WindowsMacOSLinux <pre><code>cd %AppData%/Balatro/Mods/balatrobot\nrmdir /S /Q .venv\n</code></pre> <pre><code>cd \"/Users/$USER/Library/Application Support/Balatro/Mods/balatrobot\"\nrm -rf .venv\n</code></pre> <pre><code>cd ~/.local/share/Steam/steamapps/compatdata/2379780/pfx/drive_c/users/steamuser/AppData/Roaming/Balatro/Mods/balatrobot\nrm -rf .venv\n</code></pre>"},{"location":"installation/#step-3-test-installation","title":"Step 3: Test Installation","text":""},{"location":"installation/#launch-balatro-with-mods","title":"Launch Balatro with Mods","text":"<ol> <li>Start Balatro through Steam</li> <li>In the main menu, click \"Mods\"</li> <li>Verify \"BalatroBot\" appears in the mod list</li> <li>Enable the mod if it's not already enabled and restart the game</li> </ol> <p>macOS Steam Client Issue</p> <p>On macOS, you cannot start Balatro through the Steam App due to a bug in the Steam client. Instead, you must use the <code>run_lovely_macos.sh</code> script.</p> MacOS <pre><code>cd \"/Users/$USER/Library/Application Support/Steam/steamapps/common/Balatro\"\n./run_lovely_macos.sh\n</code></pre> <p>First-time setup: If this is your first time running the script, macOS Security &amp; Privacy settings will prevent it from executing. Open System Preferences \u2192 Security &amp; Privacy and click \"Allow\" when prompted, then run the script again.</p>"},{"location":"installation/#quick-test-with-example-bot","title":"Quick Test with Example Bot","text":"<p>With Balatro running and the mod enabled, you can quickly test if everything is set up correctly using the provided example bot.</p> WindowsMacOSLinux <pre><code>cd %AppData%/Balatro/Mods/balatrobot\nuv run bots/example.py\n</code></pre> <pre><code>cd \"/Users/$USER/Library/Application Support/Balatro/Mods/balatrobot\"\nuv run bots/example.py\n</code></pre> <pre><code>cd ~/.local/share/Steam/steamapps/compatdata/2379780/pfx/drive_c/users/steamuser/AppData/Roaming/Balatro/Mods/balatrobot\nuv run bots/example.py\n</code></pre> <p>Tip</p> <p>You can also navigate to the <code>balatrobot</code> directory, activate the Python environment and run the bot with <code>python bots/example.py</code> if you prefer. However, remember to always activate the virtual environment first.</p> <p>The bot is working correctly if:</p> <ol> <li>Game starts automatically</li> <li>Cards are played/discarded automatically</li> <li>Win the first blind</li> <li>Game progresses through blinds</li> </ol>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues during installation or testing:</p> <ul> <li>Discord Support: Join our community at https://discord.gg/xzBAj4JFVC for real-time help</li> <li>GitHub Issues: Report bugs or request features by opening an issue on GitHub</li> </ul> <p>Once installation is complete, proceed to the Developing Bots to create your first bot!</p>"},{"location":"logging-systems/","title":"Logging Systems","text":"<p>BalatroBot implements three distinct logging systems to support different aspects of development, debugging, and analysis:</p> <ol> <li>JSONL Run Logging - Records complete game runs for replay and analysis</li> <li>Python SDK Logging - Future logging capabilities for the Python framework</li> <li>Mod Logging - Traditional Steamodded logging for mod development and debugging</li> </ol>"},{"location":"logging-systems/#jsonl-run-logging","title":"JSONL Run Logging","text":"<p>The run logging system records complete game runs as JSONL (JSON Lines) files. Each line represents a single game action with its parameters, timestamp, and game state before the action.</p> <p>The system hooks into these game functions:</p> <ul> <li><code>start_run</code>: begins a new game run</li> <li><code>skip_or_select_blind</code>: blind selection actions</li> <li><code>play_hand_or_discard</code>: card play actions</li> <li><code>cash_out</code>: end blind and collect rewards</li> <li><code>shop</code>: shop interactions (<code>next_round</code>, <code>buy_card</code>, <code>reroll</code>)</li> <li><code>go_to_menu</code>: return to main menu</li> </ul> <p>The JSONL files are automatically created when:</p> <ul> <li>Playing manually: Starting a new run through the game interface</li> <li>Using the API: Interacting with the game through the TCP API</li> </ul> <p>Files are saved as: <code>{mod_path}/runs/YYYYMMDDTHHMMSS.jsonl</code></p> <p>Replay runs</p> <p>The JSONL logs enable complete run replay for testing and analysis.</p> <pre><code>state = load_jsonl_run(\"20250714T145700.jsonl\")\nfor step in state:\n    send_and_receive_api_message(\n        tcp_client,\n        step[\"function\"][\"name\"],\n        step[\"function\"][\"arguments\"]\n    )\n</code></pre> <p>Examples for runs can be found in the test suite.</p>"},{"location":"logging-systems/#format-specification","title":"Format Specification","text":"<p>Each log entry follows this structure:</p> <pre><code>{\n  \"timestamp_ms\": int,\n  \"function\": {\n    \"name\": \"...\",\n    \"arguments\": {...}\n  },\n  \"game_state\": { ... }\n}\n</code></pre> <ul> <li><code>timestamp_ms</code>: Unix timestamp in milliseconds when the action occurred</li> <li><code>function</code>: The game function that was called<ul> <li><code>name</code>: Function name (e.g., \"start_run\", \"play_hand_or_discard\", \"cash_out\")</li> <li><code>arguments</code>: Arguments passed to the function</li> </ul> </li> <li><code>game_state</code>: Complete game state before the function execution</li> </ul>"},{"location":"logging-systems/#python-sdk-logging","title":"Python SDK Logging","text":"<p>The Python SDK (<code>src/balatrobot/</code>) implements structured logging for bot development and debugging. The logging system provides visibility into client operations, API communications, and error handling.</p>"},{"location":"logging-systems/#what-gets-logged","title":"What Gets Logged","text":"<p>The <code>BalatroClient</code> logs the following operations:</p> <ul> <li>Connection events: When connecting to and disconnecting from the game API</li> <li>API requests: Function names being called and their completion status</li> <li>Errors: Connection failures, socket errors, and invalid API responses</li> </ul>"},{"location":"logging-systems/#configuration-example","title":"Configuration Example","text":"<p>The SDK uses Python's built-in <code>logging</code> module. Configure it in your bot code before using the client:</p> <pre><code>import logging\nfrom balatrobot import BalatroClient\n\n# Configure logging\nlog_format = '%(asctime)s [%(levelname)s] %(name)s: %(message)s'\nconsole_handler = logging.StreamHandler()\nconsole_handler.setLevel(logging.INFO)\nfile_handler = logging.FileHandler('balatrobot.log')\nfile_handler.setLevel(logging.DEBUG)\n\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format=log_format,\n    handlers=[console_handler, file_handler]\n)\n\n# Use the client\nwith BalatroClient() as client:\n    state = client.get_game_state()\n    client.start_run(deck=\"Red Deck\", stake=1)\n</code></pre>"},{"location":"logging-systems/#mod-logging","title":"Mod Logging","text":"<p>BalatroBot uses Steamodded's built-in logging system for mod development and debugging.</p> <ul> <li>Traditional logging: Standard log levels (DEBUG, INFO, WARNING, ERROR)</li> <li>Development focus: Primarily for debugging mod functionality</li> <li>Console output: Displays in game console and log files</li> </ul> <pre><code>-- Available through Steamodded\nsendDebugMessage(\"This is a debug message\")\nsendInfoMessage(\"This is an info message\")\nsendWarningMessage(\"This is a warning message\")\nsendErrorMessage(\"This is an error message\")\n</code></pre>"},{"location":"protocol-api/","title":"Protocol API","text":"<p>This document provides the TCP API protocol reference for developers who want to interact directly with the BalatroBot game interface using raw socket connections.</p>"},{"location":"protocol-api/#protocol","title":"Protocol","text":"<p>The BalatroBot API establishes a TCP socket connection to communicate with the Balatro game through the BalatroBot Lua mod. The protocol uses a simple JSON request-response model for synchronous communication.</p> <ul> <li>Host: <code>127.0.0.1</code> (default, configurable via <code>BALATROBOT_HOST</code>)</li> <li>Port: <code>12346</code> (default, configurable via <code>BALATROBOT_PORT</code>)</li> <li>Message Format: JSON</li> </ul>"},{"location":"protocol-api/#configuration","title":"Configuration","text":"<p>The API server can be configured using environment variables:</p> <ul> <li><code>BALATROBOT_HOST</code>: The network interface to bind to (default: <code>127.0.0.1</code>)<ul> <li><code>127.0.0.1</code>: Localhost only (secure for local development)</li> <li><code>*</code> or <code>0.0.0.0</code>: All network interfaces (required for Docker or remote access)</li> </ul> </li> <li><code>BALATROBOT_PORT</code>: The TCP port to listen on (default: <code>12346</code>)</li> <li><code>BALATROBOT_HEADLESS</code>: Enable headless mode (<code>1</code> to enable)</li> <li><code>BALATROBOT_FAST</code>: Enable fast mode for faster gameplay (<code>1</code> to enable)</li> </ul>"},{"location":"protocol-api/#communication-sequence","title":"Communication Sequence","text":"<p>The typical interaction follows a game loop where clients continuously query the game state, analyze it, and send appropriate actions:</p> <pre><code>sequenceDiagram\n    participant Client\n    participant BalatroBot\n\n    loop Game Loop\n        Client-&gt;&gt;BalatroBot: {\"name\": \"get_game_state\", \"arguments\": {}}\n        BalatroBot-&gt;&gt;Client: {game state JSON}\n\n        Note over Client: Analyze game state and decide action\n\n        Client-&gt;&gt;BalatroBot: {\"name\": \"function_name\", \"arguments\": {...}}\n\n        alt Valid Function Call\n            BalatroBot-&gt;&gt;Client: {updated game state}\n        else Error\n            BalatroBot-&gt;&gt;Client: {\"error\": \"description\", ...}\n        end\n    end</code></pre>"},{"location":"protocol-api/#message-format","title":"Message Format","text":"<p>All communication uses JSON messages with a standardized structure. The protocol defines three main message types: function call requests, successful responses, and error responses.</p> <p>Request Format:</p> <pre><code>{\n  \"name\": \"function_name\",\n  \"arguments\": {\n    \"param1\": \"value1\",\n    \"param2\": [\"array\", \"values\"]\n  }\n}\n</code></pre> <p>Response Format:</p> <pre><code>{\n  \"state\": 7,\n  \"game\": { ... },\n  \"hand\": [ ... ],\n  \"jokers\": [ ... ]\n}\n</code></pre> <p>Error Response Format:</p> <pre><code>{\n  \"error\": \"Error message description\",\n  \"error_code\": \"E001\",\n  \"state\": 7,\n  \"context\": {\n    \"additional\": \"error details\"\n  }\n}\n</code></pre>"},{"location":"protocol-api/#game-states","title":"Game States","text":"<p>The BalatroBot API operates as a finite state machine that mirrors the natural flow of playing Balatro. Each state represents a distinct phase where specific actions are available.</p>"},{"location":"protocol-api/#overview","title":"Overview","text":"<p>The game progresses through these states in a typical flow: <code>MENU</code> \u2192 <code>BLIND_SELECT</code> \u2192 <code>SELECTING_HAND</code> \u2192 <code>ROUND_EVAL</code> \u2192 <code>SHOP</code> \u2192 <code>BLIND_SELECT</code> (or <code>GAME_OVER</code>).</p> State Value Description Available Functions <code>MENU</code> 11 Main menu screen <code>start_run</code> <code>BLIND_SELECT</code> 7 Selecting or skipping blinds <code>skip_or_select_blind</code>, <code>sell_joker</code>, <code>sell_consumable</code>, <code>use_consumable</code> <code>SELECTING_HAND</code> 1 Playing or discarding cards <code>play_hand_or_discard</code>, <code>rearrange_hand</code>, <code>sell_joker</code>, <code>sell_consumable</code>, <code>use_consumable</code> <code>ROUND_EVAL</code> 8 Round completion evaluation <code>cash_out</code>, <code>sell_joker</code>, <code>sell_consumable</code>, <code>use_consumable</code> <code>SHOP</code> 5 Shop interface <code>shop</code>, <code>sell_joker</code>, <code>sell_consumable</code>, <code>use_consumable</code> <code>GAME_OVER</code> 4 Game ended <code>go_to_menu</code>"},{"location":"protocol-api/#validation","title":"Validation","text":"<p>Functions can only be called when the game is in their corresponding valid states. The <code>get_game_state</code> function is available in all states.</p> <p>Game State Reset</p> <p>The <code>go_to_menu</code> function can be used in any state to reset a run. However, run resuming is not supported by BalatroBot. So performing a <code>go_to_menu</code> is effectively equivalent to resetting the run. This can be used to restart the game to a clean state.</p>"},{"location":"protocol-api/#game-functions","title":"Game Functions","text":"<p>The BalatroBot API provides core functions that correspond to the main game actions. Each function is state-dependent and can only be called in the appropriate game state.</p>"},{"location":"protocol-api/#overview_1","title":"Overview","text":"<p>| Name | Description | | ----------------------- | -------------------------------------------------------------------------------------------------- | ---------------------------------------------- | | <code>get_game_state</code> | Retrieves the current complete game state | | <code>go_to_menu</code> | Returns to the main menu from any game state | | <code>start_run</code> | Starts a new game run with specified configuration | | <code>skip_or_select_blind</code> | Handles blind selection - either select the current blind to play or skip it | | <code>play_hand_or_discard</code> | Plays selected cards or discards them | | <code>rearrange_hand</code> | Reorders the current hand according to the supplied index list | | <code>rearrange_consumables</code> | Reorders the consumables according to the supplied index list | | <code>cash_out</code> | Proceeds from round completion to the shop phase | | <code>shop</code> | Performs shop actions: proceed to next round (<code>next_round</code>), purchase (and use) a card (<code>buy_card</code> | <code>buy_and_use_card</code>), or reroll shop (<code>reroll</code>) | | <code>sell_joker</code> | Sells a joker from the player's collection for money | | <code>sell_consumable</code> | Sells a consumable from the player's collection for money | | <code>use_consumable</code> | Uses a consumable card from the player's collection (Tarot, Planet, or Spectral cards) |</p>"},{"location":"protocol-api/#parameters","title":"Parameters","text":"<p>The following table details the parameters required for each function. Note that <code>get_game_state</code> and <code>go_to_menu</code> require no parameters:</p> Name Parameters <code>start_run</code> <code>deck</code> (string): Deck name<code>stake</code> (number): Difficulty level 1-8<code>seed</code> (string, optional): Seed for run generation<code>challenge</code> (string, optional): Challenge name<code>log_path</code> (string, optional): Full file path for run log (must include .jsonl extension) <code>skip_or_select_blind</code> <code>action</code> (string): Either \"select\" or \"skip\" <code>play_hand_or_discard</code> <code>action</code> (string): Either \"play_hand\" or \"discard\"<code>cards</code> (array): Card indices (0-indexed, 1-5 cards) <code>rearrange_hand</code> <code>cards</code> (array): Card indices (0-indexed, exactly <code>hand_size</code> elements) <code>rearrange_consumables</code> <code>consumables</code> (array): Consumable indices (0-indexed, exactly number of consumables in consumable area) <code>shop</code> <code>action</code> (string): Shop action (\"next_round\", \"buy_card\", \"buy_and_use_card\", \"reroll\", or \"redeem_voucher\")<code>index</code> (number, required when <code>action</code> is one of \"buy_card\", \"redeem_voucher\", \"buy_and_use_card\"): 0-based card index to purchase / redeem <code>sell_joker</code> <code>index</code> (number): 0-based index of the joker to sell from the player's joker collection <code>sell_consumable</code> <code>index</code> (number): 0-based index of the consumable to sell from the player's consumable collection <code>use_consumable</code> <code>index</code> (number): 0-based index of the consumable to use from the player's consumable collection"},{"location":"protocol-api/#shop-actions","title":"Shop Actions","text":"<p>The <code>shop</code> function supports multiple in-shop actions. Use the <code>action</code> field inside the <code>arguments</code> object to specify which of these to execute.</p> Action Description Additional Parameters <code>next_round</code> Leave the shop and proceed to the next blind selection. \u2014 <code>buy_card</code> Purchase the card at the supplied <code>index</code> in <code>shop_jokers</code>. <code>index</code> (number) \u2013 0-based position of the card to buy <code>buy_and_use_card</code> Purchase and use the card at the supplied <code>index</code> in <code>shop_jokers</code>; only some consumables may be bought and used. <code>index</code> (number) \u2013 0-based position of the card to buy <code>reroll</code> Spend dollars to refresh the shop offer (cost shown in-game). \u2014 <code>redeem_voucher</code> Redeem the voucher at the supplied <code>index</code> in <code>shop_vouchers</code>, applying its discount or effect. <code>index</code> (number) \u2013 0-based position of the voucher to redeem <p>Future actions</p> <p>Additional shop actions such as <code>buy_and_use_card</code> and <code>open_pack</code> are planned.</p>"},{"location":"protocol-api/#development-tools","title":"Development Tools","text":"<p>These endpoints are primarily for development, testing, and debugging purposes:</p>"},{"location":"protocol-api/#get_save_info","title":"<code>get_save_info</code>","text":"<p>Returns information about the current save file location and profile.</p> <p>Arguments: None</p> <p>Returns:</p> <ul> <li><code>profile_path</code> (string) \u2013 Current profile path (e.g., \"3\")</li> <li><code>save_directory</code> (string) \u2013 Full path to Love2D save directory</li> <li><code>save_file_path</code> (string) \u2013 Full OS-specific path to save.jkr file</li> <li><code>has_active_run</code> (boolean) \u2013 Whether a run is currently active</li> <li><code>save_exists</code> (boolean) \u2013 Whether a save file exists</li> </ul>"},{"location":"protocol-api/#load_save","title":"<code>load_save</code>","text":"<p>Loads a save file directly without requiring a game restart. This is useful for testing specific game states.</p> <p>Arguments:</p> <ul> <li><code>save_path</code> (string) \u2013 Path to the save file relative to Love2D save directory (e.g., \"3/save.jkr\")</li> </ul> <p>Returns: Game state after loading the save</p> <p>Development Use</p> <p>These endpoints are intended for development and testing. The <code>load_save</code> function bypasses normal game flow and should be used carefully.</p>"},{"location":"protocol-api/#errors","title":"Errors","text":"<p>All API functions validate their inputs and game state before execution. Error responses include an <code>error</code> message, standardized <code>error_code</code>, current <code>state</code> value, and optional <code>context</code> with additional details.</p> Code Category Error <code>E001</code> Protocol Invalid JSON in request <code>E002</code> Protocol Message missing required 'name' field <code>E003</code> Protocol Message missing required 'arguments' field <code>E004</code> Protocol Unknown function name <code>E005</code> Protocol Arguments must be a table <code>E006</code> Network Socket creation failed <code>E007</code> Network Socket bind failed <code>E008</code> Network Connection failed <code>E009</code> Validation Invalid game state for requested action <code>E010</code> Validation Invalid or missing required parameter <code>E011</code> Validation Parameter value out of valid range <code>E012</code> Validation Required game object missing <code>E013</code> Game Logic Deck not found <code>E014</code> Game Logic Invalid card index <code>E015</code> Game Logic No discards remaining <code>E016</code> Game Logic Invalid action for current context"},{"location":"protocol-api/#implementation","title":"Implementation","text":"<p>For higher-level integration:</p> <ul> <li>Use the BalatroBot API <code>BalatroClient</code> for managed connections</li> <li>See Developing Bots for complete bot implementation examples</li> </ul>"}]}